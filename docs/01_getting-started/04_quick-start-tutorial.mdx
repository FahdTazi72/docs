---
title: 'Quick Start'
sidebar_label: 'Quick Start'
sidebar_position: 4
id: quick-start
---

This short guide will enable you to see the basics of the Genesis LCNC Platform by building a very simple application. It is designed simply to get from start to finish as quickly as possible.

### Pre-requisites

Before you start, you need to have:

- An IDE (preferably IntelliJ)
- Download and install the Genesis LCNC Platform

### What you will build

The very simple application you will build will look like this:

- a simple table with 5 fields
- components to display and insert data

That’s it. Just enough to get you up and running. Obviously, there is much more you could do, but that can wait for another day.

With a lack of imagination we hope you will find trustworthy, we are going to call this example application **alpha**. You will see this reflected in the file names throughout.

## Create a new project
The GenX CLI tool enables you to generate a blank application that will contain the front-end and the back-end code. From the terminal, run:

```shell
genx-cli
```

and follow the on screen instructions. 

For step by step instructions on how to install and use the tool, follow the guide on [GenX](/getting-started/using-genx).


## Define the [Data Model](/creating-applications/defining-your-application/data-model/data-model-overview)  
Now you are ready to define the fields and tables that make up your data model. This structures information in a simple way that can be viewed by users and processed by the application. 

### Add [fields](/creating-applications/defining-your-application/data-model/fields)  
You define your fields in the file **alpha-fields-dictionary.kts**.

:::tip

With your intelliJ project open hit the **shift** key twice and type in the name of the file you are looking for to find and open it quickly.

:::

For our simple example, we will add five fields

```kotlin
fields {

    field("TRADE_ID", type = STRING)
    field("QUANTITY", type = INT)
    field("PRICE", type = DOUBLE)
    field("SYMBOL", type = STRING)
    field("DIRECTION", type = ENUM("BUY", "SELL", default = "BUY"))

}
```

((Show how to run generateFields, link to page explaining in more depth what generateFields is doing))

### Add a table 
Now we have our fields, let's define a [table](/creating-applications/defining-your-application/data-model/tables) in the file **alpha-tables-dictionary.kts**.

We are defining one single table, containing all of our fields.

TRADE_ID is the primaryKey, which will be auto-generated.

```kotlin
tables {

    table (name = "TRADE", id = 2000) {
        sequence(TRADE_ID, "TR")
        QUANTITY
        PRICE
        SYMBOL
        DIRECTION

        primaryKey {
            TRADE_ID
        }
    }
    
}
```

((Show how to run generateDao, link to page explaining in ore depth what generateDao is doing))

## Add business logic
We have a table, now we want to be able to see its content and create new entries.

### Data Server
A [Data Server](/creating-applications/defining-your-application/user-interface/data-servers/data-servers) allows for reading of real-time data. You must define the Data Server in the file **alpha-dataserver.kts**.

```kotlin
dataServer {
    query("ALL_TRADES", TRADE)
}
```

### Event Handler
Next, we want to be able to insert rows into our table. For this you need to define an [Event Handler](/creating-applications/defining-your-application/business-logic/event-handlers/event-handlers/) in the file **alpha-event-handler.kts**.

```kotlin
eventHandler {

    eventHandler<Trade>(name = "TRADE_INSERT") {
        onCommit { event ->
            entityDb.insert(event.details)
            ack()
        }
    }

}
```

## Create a user interface

Now let's create a single page with a grid and a form for entering data.

After creating a hello-world-application, check if you have set a good API_HOST in **client/web/package.json**.

### Grid
We want to insert a grid with data into our page. For this we define tutorialColumnDefs in **home.template.ts**.

First, import: 

```ts
import {html, when} from '@microsoft/fast-element';
import type {Home} from './home';
import {repeat, ref} from '@microsoft/fast-element';
import {ColDef} from '@ag-grid-community/core';
import {Select} from '@microsoft/fast-foundation';
import {sync} from '@genesislcap/foundation-utils';
import {formatNumber} from '../../utils/formatting';
```

after that, add:

```ts
export const tutorialColumnDefs: ColDef[] = [
  {field: 'TRADE_ID', headerName: 'TRADE_ID'},
  {field: 'SYMBOL', headerName: 'SYMBOL'},
  {field: 'QUANTITY', headerName: 'QUANTITY'},
  {field: 'PRICE', headerName: 'PRICE', valueFormatter: formatNumber(2)},
  {field: 'DIRECTION', headerName: 'DIRECTION'},
];
```

Now we can create our zero-ag-grid in HomeTemplate const.

```ts
export const HomeTemplate = html<Home>`
<zero-card class="trade-card">
    <zero-ag-grid ${ref('tradesGrid')} rowHeight="45" only-template-col-defs>
    ${when(x => x.connection.isConnected, html`
      <ag-genesis-datasource resourceName="ALL_TRADES"></ag-genesis-datasource>
      ${repeat(() => tutorialColumnDefs, html`
        <ag-grid-column :definition="${x => x}" />
      `)}
    `)}
    </zero-ag-grid>
</zero-card>
`;
```

In **home.ts**, we need to define a reference to zero-ag-grid (remember to import AgGrid). In class home add:

```ts
public tradesGrid!: AgGrid;
```

and in ConnectedCallback add:
```ts
this.tradesGrid.addEventListener('onGridReady', () => {
  this.tradesGrid.gridApi.addEventListener('firstDataRendered', () => {
    this.tradesGrid.gridApi.sizeColumnsToFit();
  });
});
```

so our grid takes a full width.

In **home.styles.ts** we need add styles to see our changes.

```css
zero-ag-grid {
  width: 100%;
  height: 50%;
}

.trade-card {
  width: 100%;
  heigth: fit-content;
  display: flex;
  flex-direction: column;
  align-items: center;
}
```

((Link to relevant web docs section))
((Precise details needed))

### Form
Now we need a form with four inputs to insert trades to the database.
First, we need the variables that will hold the values that are entered.
We define them in **home.ts**, more precisely in the class: Home.

```ts
@observable public quantity: string;
@observable public price: string;
@observable public tradeSymbol: string;
@observable public tradeSide: string = 'BUY';
```
Now we can create our form with sync values in **home.template.ts** (add in zero-card after zero-ag-grid).

```ts
<span>Add Trade</span>
<zero-text-field type="number" :value=${sync(x=> x.quantity)}>
  <span>Quantity</span>
</zero-text-field>
<zero-text-field type="number" :value=${sync(x=> x.price)}>
  <span>Price</span>
</zero-text-field>
<zero-text-field type="text" :value=${sync(x=> x.tradeSymbol)}>
  <span>Symbol</span>
</zero-text-field>
<span>Side</span>
<zero-select @change=${((x, c)=> x.tradeSideChange(c.event.target as Select))}>
  <zero-option value='BUY'>BUY</zero-option>
  <zero-option value='SELL'>SELL</zero-option>
</zero-select>
```

To handle the value in zero-select, we need to create a function in **home.ts** (remember to import Select). 
```ts
public tradeSideChange(target: Select) {
  this.tradeSide = target.selectedOptions[0]?.value;
}
```

In **home.styles.ts**, we need add styles to see our changes.

```css
zero-text-field, zero-select {
  width: 250px;
}

span:first-of-type, zero-button {
  margin-top: 10px;
}
```

((Link to relevant web docs section))
((Precise details needed))

### Button
Now we shall add a button to insert data from form to grid.

In **home.template.ts** (after zero-select).
```ts
<zero-button @click=${x=> x.insertTradeData()}>Add Trade</zero-button>
```

In **home.ts**, create a function to handle connection to the server.

First, add just like before:

```ts
@observable public serverResponse;
```

Then, at the very end of the class, add:

```ts
public async insertTradeData() {
  this.serverResponse = await this.connection.commitEvent('EVENT_TRADE_INSERT', {
    DETAILS: {
      SYMBOL: this.tradeSymbol,
      QUANTITY: this.quantity,
      PRICE: this.price,
      DIRECTION: this.tradeSide,
    },
    IGNORE_WARNINGS: true,
    VALIDATE: false,
  });

  this.tradeSymbol = '';
  this.quantity = '';
  this.price = '';
  logger.debug('EVENT_TRADE_INSERT result -> ', this.serverResponse);
}
```

To see if the new trade was added successfully in home.template.ts, add (before Add trade span):

```ts
${when(x => x.serverResponse, html`
<span>${x=> x.serverResponse.MESSAGE_TYPE == 'EVENT_ACK' ? 
  'Succesfully added trade' : 'Something went wrong'}
</span>
`)}
```

With all this, we are now able to view and add data.

((Link to relevant web docs section))
((Precise details needed))

## Run the application

Now you can run the application from the front end, view the table of data and add the details of a new trade.

To run the application:

((Precise details needed))
((How best to have processes/service defs set up? maybe we have a quick start seed that has dataserver + event handler only?))
((How best to load a user they can log in with? or can we disable Auth???))


### Test
You should see an empty grid.

Now you can add a new trade:
((Screenshot of filled in form))

The trade appears in the grid.

Try adding more...

Refresh the page; you'll see your trades have persisted.

## Conclusion
That’s it. You have quickly built a very simple application using some of the fundamental Genesis components.

There's obviously a lot more to building enterprise-ready applications. We suggest you read through the [Defining your application](/creating-applications/defining-your-application/intro) for details of all the Genesis components and their features.

We touch on components and their features in our more advanced [tutorials](https://docs.genesis.global/secure/tutorials/building-an-application/intro/0. 

