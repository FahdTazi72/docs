---
title: 'Basics'
sidebar_label: 'Basics'
sidebar_position: 3
id: eh-technical-details
---

[Introduction](/creating-applications/defining-your-application/business-logic/event-handlers/event-handlers/)  | [Where to define](/creating-applications/defining-your-application/business-logic/event-handlers/event-handler-define/) | [Basics](/creating-applications/defining-your-application/business-logic/event-handlers/eh-technical-details/) |  [Advanced](/creating-applications/defining-your-application/business-logic/event-handlers/eh-advanced-technical-details/) | [More examples](/creating-applications/defining-your-application/business-logic/event-handlers/eh-more-examples/) | [Configuring runtime](/creating-applications/defining-your-application/business-logic/event-handlers/eh-configuring-runtime/) | [Testing](/creating-applications/defining-your-application/business-logic/event-handlers/eh-testing/)




## A simple example of an event handler

Here is a simple example of an event handler file. It defines an event handler called `COUNTERPARTY_INSERT` which inserts a counterparty into the database.
```kotlin
eventHandler {
    eventHandler<Counterparty>(name = "COUNTERPARTY_INSERT") {
        onCommit { event ->
            val counterparty = event.details
            entityDb.insert(counterparty)
            ack()
        }
    }
}
```

## Defining an event handler in GPAL

The following imports are automatically available inside GPAL event handlers:


import CodeBlock from '@theme/CodeBlock';
import Imports from '!!raw-loader!/examples/server/java/event-handlers/imports.java';

<CodeBlock className="language-java">{Imports}</CodeBlock>


### Automatic import

The following properties are automatically available inside GPAL event handlers:

```kotlin
val systemDefinition: SystemDefinitionService
val rxDb: RxDb
val entityDb: AsyncEntityDb
val metaData: MetaDataRegistry
val evaluatorPool: EvaluatorPool
val messageDelegator: MessageDelegator
val networkConfiguration: NetworkConfiguration
val serviceDetailProvider: ServiceDetailProvider
val genesisHFT: GenesisHFT
val injector: Injector
val clientConnectionsManager: ClientConnectionsManager
val typedEventManager: TypedEventManager
```

### The eventHandler code block

To define an event handler, you create an `eventHandler` code block. This must have:

* **Inbound and outbound message types**. An event handler requires one inbound message type (e.g. a generated dao entity or a custom defined message) and optionally an outbound message type. If a message type is not defined, the default _EventReply_ message type will apply. For example, `eventHandler<TradeInsert>` and `eventHandler<TradeInsert, TradeInsertReply>`.
* **Optionally, a name**. The prefix `EVENT_` will always be added to this automatically. The default name will be `EVENT_<message type name>`. So, for a message type declared as `OrderInsert`, declaring an event handler block as `eventHandler<OrderInsert>{}` automatically registers the event with the name `EVENT_ORDER_INSERT`.
* **Optionally, a boolean to define if the event handler is transactional or not**. This enables the platform to run the whole `onValidate/onCommit` block in a single ACID transaction if the database engine supports it.

Inside each event handler, you can define additional blocks and properties.

### Default reply types

The default reply types of an Event Handler are:

* `ack`: used to signify a successful result. `ack` takes an optional parameter of `List<Map<String, Any>>`. For example, `ack(listOf(mapOf("TRADE_ID", "1")))`.
* `nack`: used to signify an unsuccessful result. `nack` accepts either a _String_ parameter or a _Throwable_. For example, `nack("Error!")` or `nack(myThrowable)`.
* `warningNack`: used to warn the client. `warningNack`, like `nack`, accepts either a _String_ parameter or a _Throwable_. For example, `warningNack("Provided User alias $userAlias will override Username $username.")` or `warningNack(myThrowable)`.

### onValidate

You can declare an `onValidate` block to perform validation on each received message. The last value of the code block always needs to be the return message type.

This validation step will be executed whether the event is `validate=true` or `validate=false`.

The `onValidate` block is optional if you are using the default reply message type (`EventReply`) and will automatically be successful if not defined.

However, it is mandatory when using custom reply message types, and the script will not compile if it is not defined. See the simple example below:

```kotlin
   eventHandler<Company>(name = "COMPANY_INSERT") {
        onValidate { event ->
            val company = event.details
            require(company.companyName != "MY_COMPANY") {
                "We don't accept your company"
            }
            ack()
        }
        onCommit { event ->
            val company = event.details
            val result = entityDb.insert(company)
            ack(listOf(mapOf("COMPANY_ID" to result.record.companyId)))
        }
    }
```

Kotlin’s _require_ method throws an exception with a message if the boolean expression is not what is expected, and the event handler automatically converts that exception into a corresponding `EventNack`.

In order to optimise database lookup operations, you might want to reuse some data obtained within the `onValidate` block inside your `onCommit` block. To do this, 
use context event handlers, as shown below:

```kotlin
    contextEventHandler<Company, String>(name = "CONTEXT_COMPANY_INSERT") {
        onValidate {
            val company = it.details
            if(company.companyName == "MY_COMPANY"){
                validationAck(validationContext = "Best company in the world")
            } else {
                validationAck()
            }
        }
        onCommit { event, context ->
            val parsedContext = context ?: "Missing context"
            val company = event.details
            val result = entityDb.insert(company)
            ack(listOf(mapOf("VALUE" to parsedContext)))
        }
    }
```

As the  example shows, there is an additional type defined for the context event handler. This is a _String._ This enables us to optionally return a _String_ value from our `onValidate` block (see _validationAck_ logic) and then capture it in our `onCommit` block (see _context_ lambda parameter).

Because we are creating validation context, we need to use the function `validationAck()` and not just `ack()`.

If you use a custom reply message type, you won’t be able to use the default `ack()` or `validationAck()` functions.  The custom message type needs to be returned from the method.

For a custom message type called `TradeEvent` defined as:

```kotlin
data class TradeEvent(
    val price: Double,
    val quantity: Int,
){
    init{
        require(price > 0) { "Price cannot be negative "}
        require(quantity > 0) { "Quantity cannot be negative "}
    }
}
```

With a custom message reply type called `CustomTradeEventReply` defined as:

```kotlin
sealed class CustomTradeEventReply : Outbound() {
    class TradeEventValidateAck : CustomTradeEventReply()
    data class TradeEventAck(val tradeId: String) : CustomTradeEventReply()
    data class TradeEventNack(val error: String) : CustomTradeEventReply()
}
```

you could use the example event handler below:

```kotlin
    eventHandler<TradeEvent, CustomTradeEventReply>(name = "CUSTOM_TRADE_EVENT") {
        onException { event, throwable ->
            TradeEventNack(throwable.message!!)
        }
        onValidate {
            val tradeEvent = it.details
            require((tradeEvent.price * tradeEvent.quantity.toDouble()) < 1_000_000) { "Trade notional is too high" }
            TradeEventValidateAck()
        }
        onCommit { event ->
            val trade = event.details
            val result = entityDb.insert(trade)
            TradeEventAck(result.record.tradeId)
        }
    }
```

### onCommit

The `onCommit` block will be called when an event message is received with `validate = false` and has successfully passed the `onValidate` block. This is the place where you perform the real changes to the system, whether it is a database update or uploading a report to a third party. The last value of the code block always needs to be the return message type.

### onException

The `onException` block can capture any exceptions thrown by the `onValidate` and `onCommit` blocks and returns the expected reply message type (as shown in the last example). This function is particularly useful if you are using a custom message type, as by default Event Handlers will attempt to translate exceptions automatically to an **EventNack** message, which might cause compatibility problems if you are using custom replies.

### permissioning and permissionCodes

As with other GPAL files (e.g. request server and data server), you can use a `permissioning` block to define both dynamic permissions (AUTH) and fixed permissions (based on RIGHT_SUMMARY rights) if the event message type is a generated database entity. See the example below:

```kotlin
    eventHandler<Company>(name = "AUTH_COMPANY_INSERT") {
        permissioning {
            auth(mapName = "COMPANY"){
                COMPANY.COMPANY_NAME
            }
        }

        onCommit { event ->
            val company = event.details
            val result = entityDb.insert(company)
            ack(listOf(mapOf("VALUE" to result.record.companyId)))
        }
    }
```

If your message type is not a database-generated entity,  you can still define fixed `permissionCodes` outside the permissioning block:

```kotlin
    eventHandler<Company>(name = "AUTH_COMPANY_INSERT") {
        permissionCodes = listOf("INSERT_TRADE")
        onCommit { event ->
            val company = event.details
            val result = entityDb.insert(company)
            ack(listOf(mapOf("VALUE" to result.record.companyId)))
        }
    }
```

See [here](/creating-applications/defining-your-application/access-control/authorisation-over/) for more details.

