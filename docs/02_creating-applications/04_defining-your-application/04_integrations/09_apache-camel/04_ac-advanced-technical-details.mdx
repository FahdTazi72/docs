---
title: 'Advanced'
sidebar_label: 'Advanced'
sidebar_position: 4
id: ac-advanced-technical-details
---

[Introduction](/creating-applications/defining-your-application/integrations/apache-camel/apache-camel/)  | [Where to define](/creating-applications/defining-your-application/integrations/apache-camel/ac-define/) | [Basics](/creating-applications/defining-your-application/integrations/apache-camel/ac-technical-details/) |  [Advanced](/creating-applications/defining-your-application/integrations/apache-camel/ac-advanced-technical-details/) | [More examples](/creating-applications/defining-your-application/integrations/apache-camel/ac-more-examples/) | [Configuring runtime](/creating-applications/defining-your-application/integrations/apache-camel/ac-configuring-runtime/) | [Testing](/creating-applications/defining-your-application/integrations/apache-camel/ac-testing/)

### Automatic import

The following properties are automatically available inside GPAL Camel Definition:

```kotlin
val systemDefinition: SystemDefinitionService,
val rxDb: RxDb,
val context: DefaultCamelContext,
val producer: ProducerTemplate,
val serviceDiscovery: ServiceDiscovery,
val asyncEntityDb: AsyncEntityDb,
val rxEntityDb: RxEntityDb,
val injector: Injector,
private val eventCamelSend: EventCamelSend,
private val typedEventManager: TypedEventManager,
val LOG: Logger
```

## A more advanced example Camel configuration

Here is a more advanced example of a **\*-camel.kts** file. It defines 2 routes, and has an `onCommit` block, similar to those seen in Event Handlers. This is because the `camel` block in Genesis is functioning as a type of Event Handler, reacting to `EVENT_CAMEL_SEND` message types. These events can be raised as normal with Genesis, allowing the Event Handler to be invoked from:
- other `eventHandler` codeblocks
- the front end
- custom components in the application. 

The Event Handler aspect of this example allows these events to be accessed easily from the Apache Camel route builder via the `seda:` endpoint.

```kotlin
import global.genesis.jackson.core.GenesisJacksonMapper.Companion.csvIterator

camel {
    onCommit {
        LOG.info("Received: {}", it)
        val properties = it.details.properties
        when(val targetExtension = properties["TARGET_EXTENSION"].toString()){
            "CSV" -> DefaultCamelSendToCSV.handle(it.details, producer)
            "XML" -> DefaultCamelSendToXml.handle(it.details, producer)
        }
        EventReply.EventAck()
    }
    routeHandler {
        from("seda:PROFILE_USER")
            .process { exchange ->
                LOG.info("seda:PROFILE_USER")
                val body = exchange.message.body.toString()
                val profileUsers = body.csvIterator(ProfileUser::class.java)
                for(profileUser in profileUsers){
                    rxEntityDb.insert(profileUser).blockingGet()
                }
            }
        from("seda:MOVIES")
            .process { exchange ->
                LOG.info("seda:MOVIES")
                val body = exchange.message.body.toString()
                val movie = Movies {
                    id = "1"
                    name = body
                }
                rxEntityDb.insert(movie).blockingGet()
            }
    }
}
```

### onCommit
In the above example, the `onCommit` block reads from the properties in the received event, and uses the inbuilt `DefaultCamelSendTo*` classes to send the event message to an appropriate `seda:` endpoint. Details on the SEDA endpoint within Apache Camel can be found [here.](https://camel.apache.org/components/3.16.x/seda-component.html)

### routeHandler
In the above example, we have 2 defined routes. In both of these, we are receiving data from the `seda:` endpoints and then processing it, using an inline-defined processor. This can be useful for quickly defining a processor that isn't used elsewhere. Compared to the previous example, the results of the SEDA endpoint are directly persisted as entities in the Database, rather than being passed onto a Request Server.
