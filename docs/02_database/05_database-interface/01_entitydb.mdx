---
title: 'Database interface - Entity Db'
sidebar_label: 'Entity Db'
id: entity-db
keywords: [database, database interface, entity db]
tags:
    - database
    - database interface
    - entity db
---



import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


The entity db enables you to interact with the database layer; you can use any generated type-safe entities for
tables and views. The interface supports the same operations as the generated repositories, but will accept any
entity. It supports read operations for views and tables and write operations for tables only.

The entity db differs from the generated repositories in that it can handle any table and most view entities. It differs from `RxDb` in that all operations are type-safe.

The entity db is available in the Kotlin Event Handler.

It can be injected in Kotlin using `AsyncEntityDb` and in Java using `RxEntityDb`.

There are three versions of the entity db:

* `AsyncEntityDb` - this API supports Kotlin coroutines
* `SyncEntityDb` - this API is blocking
* `RxEntityDb` - this API supports RxJava

:::important

The `SyncEntityDb` API was introduced in version 7.0 of the Genesis platform.

:::

## Which version to use?

The version to use depends on:

- whether you are writing code in Kotlin or Java
- whether there is a need to write asynchronous (async) or synchronous (blocking) code

|        | Asynchronous    | Blocking       |
|--------|-----------------|----------------|
| Kotlin | `AsyncEntityDb` | `SyncEntityDb` |
| Java   | `RxEntityDb`    | `SyncEntityDb` |

For more information on the differences between the APIs, see [Types of API](../../../database/types-of-api/types-of-api/).

|                                                                                                        | [EntityDb](../../../database/database-interface/entity-db/)                                                     |
|--------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| [Supports tables](../../../database/fields-tables-views/tables/tables-basics/)                                 | ✔️                                                                                                      |
| [Supports views](../../../database/fields-tables-views/views/views-basics/)                                    | ✔️                                                                                                      |
| Supports any data type                                                                                 | ✔️                                                                                                      |
| Class to import                                                                                        | `AsyncEntityDb` <br/> `RxEntityDb`                                                                      |
| Type-safe read and write                                                                               | ✔️                                                                                                      |
| Type-safe write result                                                                                 | ✔️                                                                                                      |
| Returns data as  | [table](../../../database/data-types/table-entities/) or [view](../../../database/data-types/views-entities/) entities   |
| Writes data as   | [table](../../../database/data-types/table-entities/) or [view](../../../database/data-types/views-entities/) entities   |
| References indexes as                                                                                  | [index entities](../../../database/data-types/index-entities/)                                                  |
| Programming interface                                                                                  | [Async](../../../database/types-of-api/async/) or [RxJava](../../../database/types-of-api/rxjava/)                      |
| Write (input)                                                                                          | [Modify Details](../../../database/helper-classes/modify-details/#entity-modify-details)                        |
| Write (output)                                                                                         | [Write Result](../../../database/helper-classes/write-result/#entity-write-result)                              |
| Subscribe                                                                                              | [Record Update](../../../database/helper-classes/subscription/record-update/) of entity                         |
| Bulk or Range Subscribe                                                                                | [Bulk](../../../database/helper-classes/subscription/bulk/) of entity                                           |
| Available in [Custom Event Handlers](../../../server/api-reference/event-handler-api/)                       | ✔️                                                                                                      |
| Available in [Custom Request Servers](../../../server/request-server/advanced/#custom-request-servers) | ✔️                                                                                                      |


When referring to indices in the database operations, the database accepts _index classes_ or _entity class_ in combination with _index references_. For comparison:

## Type convention

| Type                               | Meaning                           | Example        |
|------------------------------------|-----------------------------------|----------------|
| `E`                                | A table or view entity            | `Trade`        |
| `T`                                | A table entity                    | `Trade`        |
| `V`                                | A view entity                     | `TradeView`    |
| `EntityIndex<E>`                   | An index of E                     | `Trade.ById`   |
| `UniqueEntityIndex<E>`             | A unique index of E               | `Trade.ById`   |
| `NonUniqueEntityIndex<E>`          | A non unique index of E           | `Trade.ByDate` |
| `EntityIndexReference<E>`          | An index reference of E           | `Trade.ById`   |
| `UniqueEntityIndexReference<E>`    | A unique index reference of E     | `Trade.ById`   |
| `NonUniqueEntityIndexReference<E>` | A non unique index reference of E | `Trade.ByDate` |
| `F<E>`                             | The full table /view name for E   | `TRADE`        |
| `Class<E>`                         | The class reference for E         | `Trade.class`  |
| `KClass<E>`                        | The Kotlin class reference for E  | `Trade::class` |


## Read operations

### get

Get is a simple lookup on the database; it will return a single entity if a match is found, or no records if none is
found.

The following overloads exist for get; `fields` is a `Set<String>`.

* `get(E, EntityIndexReference<E>, fields) : E?`
* `get(E, fields) : E?`
* `get(E, EntityIndexReference<E>) : E?`
* `get(UniqueEntityIndex<E>, fields) : E?`
* `get(UniqueEntityIndex<E>) : E?`

#### Syntax

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java - RxJava', value: 'java', }, { label: 'Java - Blocking', value: 'java-sync', }]}>
<TabItem value="kotlin">

```kotlin
// we can look up trades by passing in a unique index class:
val trade = db.get(Trade.byId("TRADE_1"))

// a trade object with the primary key set
val trade = db.get(trade)

// a trade object and a reference to unique index
val trade = db.get(trade, Trade.ByTypeId)

// or you can access the index class from the entity
val trade = db.get(trade.byTypeId())
```

</TabItem>
<TabItem value="java">

```java
// we can look up trades by passing in a unique index class:
final var trade = db.get(Trade.byId("TRADE_1"))
        .blockingGet();

// a trade object with the primary key set
final var trade = db.get(trade)
        .blockingGet();

// a trade object and a reference to unique index
final var trade = db.get(trade,Trade.ByTypeId.Companion)
        .blockingGet();

// or you can access the index class from the entity
final var trade = db.get(trade.byTypeId())
        .blockingGet();
```
</TabItem>
<TabItem value="java-sync">

```java
// we can look up trades by passing in a unique index class:
final var trade = db.get(Trade.byId("TRADE_1"))

// a trade object with the primary key set
final var trade = db.get(trade)

// a trade object and a reference to unique index
final var trade = db.get(trade,Trade.ByTypeId.Companion)

// or you can access the index class from the entity
final var trade = db.get(trade.byTypeId())
```
</TabItem>
</Tabs>

### getAll

This takes multiple _unique_ index class instances and returns the type entity type for the record. It takes
a `List<Pair<String, UniqueEntityIndex<E>>>`, where the `String` is a unique reference to each request.

#### Overloads

* `getAll(requestDetails: Flow<Pair<String, UI<E>>): Map<String, E?>`
* `getAll(requestDetails: List<Pair<String, UI<E>>): Map<String, E?>`

```kotlin
val map = db.getAll(listOf("A" to Trade.byId("TRADE_A"), "B" to Trade.byId("TRADE_B")))

val recordA = map["A"]
val recordB = map["B"]
```

### getAllAsList

This operation is similar to the one above, but takes a `List<UniqueEntityIndex<E>>`, and returns a `List<E?>`.
The results are returned in the order they were requested and will be `null` if no record was found. The result
list is guaranteed to be the same count as the input.

#### Overloads

* `getAllAsList(Flow<UI<E>>): List<E?>`
* `getAllAsList(List<UI<E>>): List<E?>`
* `getAllAsList(vararg UI<E>): List<E?>`

```kotlin
val list = db.getAllAsList(Trade.byId("TRADE_A"), Trade.byId("TRADE_B"))

val recordA = list[0]
val recordB = list[1]
```

### getBulk

This operation creates a `Flowable` of the whole table. If the database layer supports it, the records will be
sorted in ascending order by the index provided, or by the primary key if none is provided.

Currently, only FoundationDb and Postgres support an ordered `getBulk`. There is also the `getBulkFromEnd` function, which returns records in descending order.

There are also a number of continuation operations, which return the whole table after the provided record. These methods are deprecated and should not be used going forwards.

#### Overloads

* `getBulk<E>(): Flow<E>` (Kotlin only)
* `getBulk([Class<E> /  KClass<E>]): Flow<E>`
* `getBulk(UR<E>): Flow<E>`
* `getBulk(UR<E>, fields): Flow<E>`
* `getBulk(UR<E>, E, fields): Flow<E>` (continuation) (Deprecated)
* `getBulkFromEnd(UR<E>): Flow<E>`
* `getBulkFromEnd(UR<E>, E), E: Flow<E>` (continuation) (Deprecated)
* `getBulkFromEnd(UR<E>, E, fields), E: Flow<E>` (continuation) (Deprecated)
* `getBulkFromEnd(UR<E>, fields): Flow<E>`

#### Syntax

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// we can pass in Trade as a type parameter
    // todo undo...
val flow = db.getBulk  --- Trade>()
// we can pass in the TRADE object
val flow = db.getBulk(TRADE)
// or we can pass in an index reference
val flow = db.getBulk(Trade.ByTypeId)
```

</TabItem>
<TabItem value="java">

```java
// we can pass in Trade as a type parameter
final var flowable = db.getBulk(Trade.class);
// we can pass in the TRADE object
final var flowable = db.getBulk(TRADE.INSTACE);
// or we can pass in an index reference
final var flowable = db.getBulk(Trade.ById.Companion);
```
</TabItem>
</Tabs>

### getRange

`getRange` is an operation that can return multiple records from the database.

There are two types of `getRange` operation:

* Single-value range, e.g. trades with CURRENCY set to USD
* Interval range, e.g. all trades with TRADE_DATE between 01-Jul-2024 and 01-Aug-2024.

Unlike the `get` operation, the `getRange` operation can always return multiple records.

We pass index entities into `getRange`. When using an interval range, both index entities should be of the same type. in the example below, this is `Trade.byDate`.

<Tabs defaultValue="kotlin" values={[{label: 'Kotlin', value: 'kotlin',}, {label: 'Java', value: 'java',}]}>
<TabItem value="kotlin">

```kotlin
// single value
val range = db.getRange(Trade.byCurrency("USD"))

// interval
val range = db.getRange(
    Trade.byDate(myStartDate),
    Trade.ByDate(myEndDate)
)
```

</TabItem>
<TabItem value="java">

```java
// single value
var range = db.getRange(Trade.byCurrencyId("USD"));

// interval
var range = db.getRange(
    Trade.byDate(startDate),
    Trade.byDate(endDate)
);
```

</TabItem>
</Tabs>

Table entities provide methods for building index entities:

<Tabs defaultValue="kotlin" values={[{label: 'Kotlin', value: 'kotlin',}, {label: 'Java', value: 'java',}]}>
<TabItem value="kotlin">

```kotlin
// single value
val range = getRange(myUsdTrade.byCurrency())

// interval
val range = db.getRange(myStartTrade.byDate(), myEndTrade.byDate())
```

</TabItem>
<TabItem value="java">

```kotlin
// single value
var range = getRange(myUsdTrade.byCurrency());

// interval
var range = db.getRange(myStartTrade.byDate(), myEndTrade.byDate());
```

</TabItem>
</Tabs>

#### `numKeyFields` property

This allows users to query on part of the index. When using the `getRange` operation, you can tell the database how many fields in the index to use.

By default, all fields are used, but you can override this. 


:::note
Order matters here; you can get a range on just field 1, field 1 and field 2, but not on field 2 and field 1.
:::

For example, if on the ORDER table, we had an index on COUNTERPARTY and INSTRUMENT_ID, we could:

- perform a single-value `getRange` operation on `COUNTERPARTY`. For this, set `numKeyFields` to `1`.
- perform a single-value `getRange` operation on both `COUNTERPARTY` and `INSTRUMENT`. For this, set `numKeyFields` to `2`.

For example:

<Tabs defaultValue="kotlin" values={[{label: 'Kotlin', value: 'kotlin',}, {label: 'Java', value: 'java',}]}>
<TabItem value="kotlin">

```kotlin
// we could look up all rows for both COUNTERPARTY and INSTRUMENT:
val range = db.getRange(myOrder.byCounterpartyAndInstrument())
// which would be equivalent to
val range = db.getRange(myOrder.byCounterpartyAndInstrument(), 2)
// and also
val range = db.getRange(Order.byCounterpartyAndInstrument("CPTY_A", "VOD"))

// or we could look pu by just COUNTERPARTY
val range = db.getRange(myOrder.byCounterpartyAndInstrument(), 1)
// which would be equivalent to
val range = db.getRange(Order.byCounterpartyAndInstrument("CPTY_A"))
```

</TabItem>
<TabItem value="java">

```java
// we could look up all rows for both COUNTERPARTY and INSTRUMENT:
var range = db.getRange(myOrder.byCounterpartyAndInstrument());
// which would be equivalent to
var range = db.getRange(myOrder.byCounterpartyAndInstrument(), 2);
// and also
var range = db.getRange(Order.byCounterpartyAndInstrument("CPTY_A", "VOD"));

// or we could look pu by just COUNTERPARTY
var range = db.getRange(myOrder.byCounterpartyAndInstrument(), 1));
// which would be equivalent to
var range = db.getRange(Order.byCounterpartyAndInstrument("CPTY_A"));
```

</TabItem>
</Tabs>

:::info
`numKeyFields` is required in the following instances:

* when passing in a table entity and an index reference
* when passing in an index entity that refers to a unique index
:::

#### Fields

When using a `getRange` operation, you can provide a `Set<String>` with the field names you want to select.
This will only be used as a hint; non-nullable fields will always be returned from the database.

<Tabs defaultValue="kotlin" values={[{label: 'Kotlin', value: 'kotlin',}, {label: 'Java', value: 'java',}]}>
<TabItem value="kotlin">

```kotlin
val range = getRange(
    myUsdTrade.byCurrency(),
    fields = setOf("PRICE", "QUANTITY")
)

```

</TabItem>
<TabItem value="java">

```kotlin
var range = db.getRange(
    Trade.byCurrencyId("USD"),
    1,
    Set.of("PRICE", "QUANTITY")
);
```

</TabItem>
</Tabs>

#### Reversed range lookups

In addition to `getRange` there is also the `getRangeFromEnd` method.
This works in the same way as `getRange`. However, rows are returned in the reverse order.

#### Parameters when using index entities

| Name         | Type             | Required                    | Meaning                                       | Default value           |
|--------------|------------------|-----------------------------|-----------------------------------------------|-------------------------|
| Index        | `EntityIndex<E>` | ✔️, For single value ranges | The index entry to read                       |                         |
| Start index  | `EntityIndex<E>` | ✔️, For interval ranges     | The index entry to read from                  |                         |
| End index    | `EntityIndex<E>` | ✔️, For interval ranges     | The index entry to read to                    |                         |
| numKeyFields | `Int`            | ❌                          | The number of key fields to take into account | All fields in the index |
| fields       | `Set<String>`    | ❌                          | The names of the fields to return             | return all fields       |

## Write operations

All write operations have versions that take a single entity and versions that take multiple entries.

The return values for these operations are type-safe (see details below), provided all entries are of the same type. For example, when inserting multiple `Trade` entries, the return type will be `List<InsertResult<Trade>>`. Different entity types can be inserted in the same operation; however, the return type will be `List<InsertResult<Entity>>`. Also, modify operations
only accept table entities.

### Default and generated values

When writing a record to the database, typically all non-null properties should be set on the entity. An entity property becomes non-nullable if:

* it has a default value
* it is generated by the database, i.e. sequence or auto increment fields
* the column is included in an index or is specifically declared not null in the schema

#### Default values

Properties with a default value will have the value set by default, unless set explicitly in the builder.

#### Generated properties

Generated properties are left in an indeterminate state if not set in the builder. When writing to the database, this indeterminate state is set in the return value. Trying to read the property while it is in this state results in an `IllegalArgumentException`. 

Each generated property has only two read-only associated properties to access these properties in a safe manner. 

- `is[FieldName]Generated` boolean property
- `[fieldName]OrNull` property

For example:

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// tradeId is generated
trade.tradeId                   // will cause an exception if not initialised
trade.tradeIdOrNull             // will return the tradeId if set, or else null
trade.isTradeIdInitialised      // will return true if set
```

</TabItem>
<TabItem value="java">

```java
// tradeId is generated
trade.getTradeId();             // will cause an exception if not initialised
trade.getTradeIdOrNull();       // will return the tradeId if set, or else null
trade.isTradeIdInitialised();   // will return true if set
```
</TabItem>
</Tabs>

#### Columns in indices or are not null explicitly

Columns in indices or declared not null should always be set in a builder, unless it has a default value or is a generated column. In all other instances, a `NullPointerException` will be thrown when building the object.

### Insert

This inserts a new record into the database. The `insert` function takes a single table entity. The `insertAll` function takes multiple records, and has several overloads:

#### Overloads

* `insert(E): InsertResult<E>`
* `insertAll(vararg E): List<InsertResult<E>>`
* `insertAll(List<E>): List<InsertResult<E>>`
* `insertAll(Flow<E>): List<InsertResult<E>>`

### Modify

This tries to modify a record in the database. If the record does not exist, an error is thrown.

#### Overloads

* `modify(EntityModifyDetails<E>): ModifyResult<E>`
* `modify(E): ModifyResult<E>`
* `modify(E, UniqueEntityIndexReference<E>): ModifyResult<E>`
* `modifyAll(vararg E): List<ModifyResult<E>>`
* `modifyAll(vararg EntityModifyDetails<E>): List<ModifyResult<E>>`
* `modifyAll(List<EntityModifyDetails<E>>): List<ModifyResult<E>>`
* `modifyAll(Flow<EntityModifyDetails<E>>): List<ModifyResult<E>>`

### Upsert

This tries to modify a record in the database. If the record does not exist, the record is inserted instead.

#### Overloads

* `upsert(EntityModifyDetails<E>): UpsertResult<E>`
* `upsert(E): UpsertResult<E>`
* `upsertAll(vararg E): List<UpsertResult<E>>`
* `upsertAll(vararg EntityModifyDetails<E>): List<UpsertResult<E>>`
* `upsertAll(List<EntityModifyDetails<E>>): List<UpsertResult<E>>`
* `upsertAll(Flow<EntityModifyDetails<E>>): List<UpsertResult<E>>`

### Delete

This tries to delete a record.

#### Overloads

* `delete(E): DeleteResult<E>`
* `delete(UniqueEntityIndex<E>): DeleteResult<E>`
* `deleteAll(vararg E): List<DeleteResult<E>>`
* `deleteAll(vararg UniqueEntityIndex<E>): List<DeleteResult<E>>`
* `deleteAll(List<E>): List<DeleteResult<E>>`
* `deleteAll(Flow<E>): List<DeleteResult<E>>`

### Update

The update operation is a condensed syntax for modifying data in the database. It works by providing a scope and a transformation. The scope could be one of:

* `updateBy` - a unique index
* `updateRangeBy` - an index range
* `updateAll` - a whole table

The transformation is a lambda, where the rows that are in scope are provided one by one. The rows are provided as in
the database, and can be modified in place, with the changes applied to the database. All update calls use the
`safeWriteTransaction` and are transactional if the database supports it.

* In the async entity db, the lambda will be of type `E.() -> Unit`. The entity will be the receiver and in the lambda,
`this` will refer to the row, which should be modified in place.

* In the rx entity db, the lambda will be of type `Consumer<E>`. The lambda will have a single parameter, the entity.
Similar to the async version, the row should be modified in place.

In both cases, the full record will be provided, and values can be read as well as updated. The operations return
`List<ModifyResult<E>>` for `updateAll` and `updateRangeBy` methods and `ModifyResult<E>` for the `updateBy` operation.

For example:

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
db.updateBy(Trade.byId("xxxxx")) {
    price = 15.0
}

db.updateByRange(Trade.byOrderId("xxxx")) {
    orderStatus = OrderStatus.CANCELLED
}

db.updateByRange(Trade.byOrderId("xxxx"), Trade.byOrderId("yyyy") {
    orderStatus = OrderStatus.CANCELLED
}

db.updateAll<Trade> {
    orderStatus = OrderStatus.CANCELLED
}
```

</TabItem>
<TabItem value="java">

```java
db.updateBy(Trade.byId("xxx"), trade -> {
    trade.setPrice(15.0);
}).blockingGet();

db.updateByRange(Trade.byOrderId("xxxx"), trade -> {
    trade.setTradeType(OrderStatus.CANCELLED);
}).blockingGet();

db.updateByRange(Trade.byOrderId("xxxx"), Trade.byOrderId("yyyy"), trade -> {
    trade.setTradeType(OrderStatus.CANCELLED);
}).blockingGet();

db.updateAll(Trade.class, trade -> {
    trade.setTradeType(OrderStatus.CANCELLED);
}).blockingGet();
```

</TabItem>
</Tabs>

### Recover

The `recover` operation enables you to insert a document into the database using the record's preset timestamp and ID.

The following recover operations are supported:

- `recover`
- `recoverAll`

:::danger

This API must be used with caution. Integrity checks are skipped, so it can leave your Genesis application in a poor state if used incorrectly. Record IDs and timestamps are assumed to be unique.

:::

## Transactions

If the underlying database supports transactions, then the entity db provides type-safe access to these. A read transaction will support the same read operations as the entity db, and a write transaction will support the same read and write operations. If a write transaction fails, all operations will be reverted. Subscribe operations are not supported within transactions.

Transactions are supported on database layers: **FoundationDb**, **MS SQL**, **Oracle** and **Postgresql**.

When code is expected to run on multiple database types, transactions should be used when available. You can use `safeReadTransaction` and `safeWriteTransaction`. These run operations in the block in a single transaction, if supported.

There is a distinction between using Kotlin and Java here.

* When using Kotlin, the transaction is the receiver in the `readTransaction` call. This means that within the block, `this` refers to the transaction.
* When using Java, the transaction is the first parameter of the lambda.

### Read transactions

Read transactions ensure that all read operations are consistent. Intervening writes will not affect reads within the
transaction. The return value in the transaction will also be returned from the transaction. For the `RxEntityDb`, it
will be a `Single<*>`.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val orderTrade = db.readTransaction {
    val trade = get(Trade.byId("TR_123"))
    val order = get(Order.byId(trade.orderId))
    buildOrderTrade(order, trade)
}
```

</TabItem>
<TabItem value="java">

```java
Single<OrderTrade> orderTrade = db.readTransaction(transaction -> {
    final var trade = transaction.get(Trade.byId("TR_123")).blockingGet();
    final var order = transaction.get(Order.byId(trade.orderId)).blockingGet();
    return buildOrderTrade(order, trade);
});
```
</TabItem>
</Tabs>

### Write transactions

Write transactions ensure all read and write operations are consistent. If any exception reaches the
transaction level, all writes are rolled back. The `writeTransaction` will return a `Pair<T, List<EntityWriteResult<*>>>`,
where `T` is the value returned in the `writeTransaction` lambda.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val (orderId, writeResults) = db.writeTransaction {
    insert(trade)
    val orderInsert = insert(order)
    orderInsert.record.orderId
}
```

</TabItem>
<TabItem value="java">

```java
final var pair = db.writeTransaction(transaction -> {
    insert(trade).blockingGet();
    final var orderInsert = insert(order).blockingGet();
    return orderInsert.getRecord.getOrderId();
}).blockingGet();
final var orderId = pair.getFirst();
final var writeResults = pair.getSecond();
```
</TabItem>
</Tabs>

## Subscribe operations

### Subscribe

The `subscribe` operation starts a database listener that receives updates to tables or views.

### Subscribe parameters
Subscribe supports the following parameters:

| Name | Type | Required | Meaning | Default value |
| --- | --- | --- | --- | --- |
| Table name | `String`| ✔️ | The table to subscribe to | n/a |
| fields | `Set<String>` | ❌ | Only listen to changes on selected fields | listen to all fields |
| delay | `Int` | ❌ | Group and publish updates every x ms | no grouping |
| subscribeLocally | `Boolean` | ❌ | When in a cluster, only listen to local updates | false |


#### Overloads

The rx entity db takes a `Class<E>`, whereas the async entity db takes a `KClass<E>`.
Parameters marked with an asterisk(*) are optional.

1. `subscribe([KClass<E> / Class<E>], delay*, fields*, subscribeLocally*): Flow<E>`

These functions are available in kotlin only:

2. `subscribe<E>(delay*, fields*, subscribeLocally*): Flow<E>`

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val subscription = launch {
    db.subscribe<Trade>()
        .collect { update ->
            println("Received a trade update! $update")
        }
}
```

</TabItem>
<TabItem value="java">

```java
final var subscription = db.subscribe(Trade.class)
        .subscribe(update -> {
            System.out.println("Received a trade update! " + update);
        });
```
</TabItem>
</Tabs>

### Bulk subscribe

The `bulkSubscribe` operation combines a [`getBulk`](#getbulk) and a [`subscribe`](#subscribe) call into a single operation.
This is useful when a class needs to read a full table and then receive updates of changes to the underlying table or view.

This operation supports [backwards joins for views]](../../../database/fields-tables-views/views/views-examples/). This means that it can receive updates on both the
root table and the joined tables. The view needs to support this in the definition, and it must be enabled on the `bulkSubscribe` call.

#### Example

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val bulk = db.bulkSubscribe<Trade>()
```

</TabItem>
<TabItem value="java">

```java
var bulk = db.bulkSubscribe(Trade.class);
```

</TabItem>
</Tabs>

#### Parameters

`bulkSubscribe` supports the following parameters:

| Name | Type | Required | Meaning | Default value |
| --- | --- | --- | --- | --- |
| Table |`Class<E>`| ✔️ | The table to subscribe to |   |
| Index |`UniqueEntityIndexReference<E>`| ❌ | The to sort the getBulk operation by |   |
| fields | `Set<String>` | ❌ | Only listen to changes on selected fields (filters `ModifyResult` on fields)| listen to all fields |
| delay | `Int` | ❌ | Batch updates x ms | no batching |
| subscribeLocally | `Boolean` | ❌ | When in a cluster, only listen to local updates | false |
| backwardJoins  | `Boolean` | ❌ | subscribe to changes on sub tables (backwards joins) | false |

#### Java support

There are many optional parameters for bulk subscribe operations. In Kotlin, this works well in a single method due to named parameters and default values.

In Java, however, we provide a fluent API to set optional parameters.

The function `bulkSubscribeBuilder` returns a builder.

Optional parameters can be set with a "with-function", e.g. `withDelay(...)`.

Once all values have been set, the `toFlowable()` function transforms the builder into a `Flowable`.

#### More complex example

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val bulk = db.bulkSubscribe<Trade>(
    fields = setOf("TRADE_DATE"),
    delay = 500,
    subscribeLocally = false,
    index = Trade.ByTypeId,
    backwardJoins = true,
)
```

</TabItem>
<TabItem value="java">

```java
var bulk = db.bulkSubscribeBuilder(Trade.class)
    .withFields(Set.of("TRADE_DATE"))
    .withDelay(500)
    .withSubscribeLocally(false)
    .withIndex(Trade.ByTypeId.Companion)
    .withBackwardJoins(true)
    .toFlowable();
```

</TabItem>
</Tabs>

### Range subscribe

`rangeSubscribe` is similar to `bulkSubscribe`. The `rangeSubscribe` operation combines a [`getRange`](#getrange) and a [`subscribe`](#subscribe) call into a single operation.
This is useful when a class needs to read a full table and then receive updates of changes to the underlying table or view.

This operation supports [backwards joins for views]](../../../database/fields-tables-views/views/views-examples/). This means that it can receive updates on both the root table and the joined tables. The view needs to support this in the definition, and it must be enabled on the `bulkSubscribe` call.

#### Different range options

Like `getRange`, `rangeSubscribe` supports single-value and interval ranges.
In addition, range subscribe supports both static and dynamic ranges. See below for details. 

#### Note on Java

Like `bulkSubscribe` there are many optional parameters for range subscribe operations. In Kotlin, this works well in a single method due to named parameters and default values.

In Java however, we provide a fluent API to set optional parameters.

The functions `staticRangeSubscribeBuilder` and `dynamicRangeSubscribeBuilder` return a builder.

Optional parameters can be set with a "with-function", e.g. `withDelay(...)`.

Once all values have been set, the `toFlowable()` function transforms the builder into a `Flowable`.

#### Static ranges

By default, ranges are static; they are set at the start of the subscription and not updated afterwards.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// single-value range
val range = db.rangeSubscribe(Trade.byCurrencyId("USD))

// interval range
val range = db.rangeSubscribe(
    Trade.byDate(startDate),
    Trade.byDate(endDate)
)

```

</TabItem>
<TabItem value="java">

```java
// single-value range
var range = db.staticRangeSubscribeBuilder(Trade.byCurrencyId("USD"))
    .toFlowable();
// interval range
var range = db.staticRangeSubscribeBuilder(
        Trade.byDate(startDate),
        Trade.byDate(endDate)
    )
    .toFlowable();
```

</TabItem>
</Tabs>

#### Dynamic ranges

Additionally, `rangeSubscribe` also supports dynamic ranges. These are ranges that are refreshed either at a specified time, or interval.

This can be useful for long-running subscriptions on dates. For example, you might want to keep an eye on trades booked in the last hour. Unless that range is refreshed, it will fall behind.

In the example below, we have two dynamic ranges. 

- The first one filters on a specific date, and is updated at midnight.
- The second one has a 2-hour window, and is updated every 5 minutes.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// single-value range
db.rangeSubscribe(
    fromProvider = { Trade.byDate(DateTime.now().withTimeAtStartOfDay()) },
    updateFrequency = PalDuration.At(LocalTime.MIDNIGHT)
)
// interval range
db.rangeSubscribe(
    fromProvider = { Trade.byDate(DateTime.now().minusHours(1)) },
    toProvider = { Trade.byDate(DateTime.now().plusHours(1)) },
    updateFrequency = PalDuration.Every(Duration.ofMinutes(5))
)
```

</TabItem>
<TabItem value="java">

```java
// single-value range
var range = db.dynamicRangeSubscribeBuilder(
        () -> Trade.byDate(DateTime.now().withTimeAtStartOfDay())
    ).withUpdateFrequency(new PalDuration.At(LocalTime.MIDNIGHT))
        .toFlowable();
// interval range
var range = db.dynamicRangeSubscribeBuilder(
        () -> Trade.byDate(DateTime.now().minusHours(1)),
        () -> Trade.byDate(DateTime.now().plusHours(1))
    ).withUpdateFrequency(new PalDuration.Every(Duration.ofMinutes(5)))
        .toFlowable();
```

</TabItem>
</Tabs>

#### Parameters

For static ranges `rangeSubscribe` supports the parameters below.

In the Java API, the function returns a builder, where optional parameters can be set.

| Name             | Type             | Required            | Meaning                                                                      | Default value        |
|------------------|------------------|---------------------|------------------------------------------------------------------------------|----------------------|
| Start index      | `EntityIndex<E>` | ✔️                  | The index entry to read from                                                 |                      |
| End index        | `EntityIndex<E>` | For interval ranges | The index entry to read to                                                   |                      |
| numKeyFields     | `Int`            | ❌️                  | The number of key fields to take into account for the range                  |                      |
| updateFrequency  | `PalDuration`    | For dynamic ranges  | A schedule to update dynamic range boundaries                                | ?                    |
| delay            | `Int`            | ❌                  | Group and publish updates every x ms                                         | 200ms                |
| fields           | `Set<String>`    | ❌                  | Only listen to changes on selected fields (filters `ModifyResult` on fields) | listen to all fields |
| subscribeLocally | `Boolean`        | ❌                  | When in a cluster, only listen to local updates                              | false                |
| backwardJoins    | `Boolean`        | ❌                  | subscribe to changes on sub-tables (backwards joins)                         | false                |

#### Example
<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val range = asyncEntityDb.rangeSubscribe(
    from = Trade.byDate(startDate),
    to = Trade.byDate(endDate),
    numKeyFields = 1,
    delay = 500,
    fields = emptySet(),
    subscribeLocally = true,
    backwardJoins = true
)

```

</TabItem>
<TabItem value="java">

```java
val range = db.staticRangeSubscribeBuilder(
        Trade.byDate(startDate),
        Trade.byDate(endDate)
    )
    .withNumKeyFields(1)
    .withDelay(500)
    .withFields(Collections.emptySet())
    .withSubscribeLocally(true)
    .withBackwardJoins(true)
    .toFlowable();
```

</TabItem>
</Tabs>

### Subscribing on views

There are some subtleties when it comes to subscriptions on views.

- Generally, only updates on the root table will be published
- Updates relate to the view, not the table.

For this, we will use the following example view.

```kotlin
views {
    view("TRADE_VIEW", TRADE) {
        joins {
            joining(INSTRUMENT, backwardsJoin = true, joinType = JoinType.INNER) {
                on(TRADE.INSTRUMENT_ID to INSTRUMENT.ID)
            }
        }

        fields {
            TRADE.allFields()
            INSTRUMENT.NAME withPrefix INSTRUMENT
        }
    }
}
```

#### Root table updates and backwards joins

By default, when subscribing to updates on a view, only updates on the root table are sent. If you want updates on the joined table or tables, you must enable `backwardsJoin` on the join.
If we don't enable backwards joins, then we would receive an update, if and only if TRADE is updated.
With `backwardsJoin` enabled however, we will also receive updates if a related INSTRUMENT record is updated.

For example, if TRADE 001 is updated; we will received an update on TRADE_VIEW for that trade.
If INSTRUMENT X is updated, we will receive an update on TRADE_VIEW for all trades related to that record.

#### View updates - inner joins

In the example above, we have an inner join from TRADE to INSTRUMENT.
This means that, from the view's perspective, a TRADE_VIEW record only exists, if a TRADE joins onto an INSTRUMENT
Following on from there, if the INSTRUMENT_ID on TRADE is updated from XX to YY, and INSTRUMENT XX exists
but INSTRUMENT YY does not, the MODIFY update on the TRADE will result in a DELETE update on TRADE_VIEW.
If we were to revert that change, that MODIFY would result in an INSERT update.

## Update batching

Above there have been several references to delays in the subscribe methods.
This delay is used to determine the batching interval on updates.
By default, rather than publishing every update received, updates will be compressed.
We do this to reduce the load on high volume systems.

For example, if a trade is inserted, and then modified rapidly in quick succession, oftentimes we are not interested
in all the intermediate states.
It will be easier for the system to just press a single update, so the insert and modify can get merged into a single
insert update.

### Batching phases

Batching happens in two phases:
1. we gather updates
2. at an interval we receive a tick and we aggregate and flush updates

So what does this mean in practice?
The batching period is always set globally, i.e. for a update queue subscription or on a data server query.
Never on the individual row level.

The goal of this batching is to minimise work, and to publish updates that are accurate, rather than to publish every change.

In this regard it is better to think in terms of a batching interval, rather than a batching period, which looks something like this:

```
...
*
|---- gathering phase ----| (batching period)
*
*
*
*
*
|---- flushing phase -----| (tick happens here)
* aggregate updates
* publish updates
|---- gathering phase ----| (next batching period)
*
*
...
```

### Batching is non-deterministic

During our gathering phase, we listen for updates; and during the flushing phase, we aggregate and publish.

Let's look at an example:

Imagine we insert a trade with quantity 100. Within milliseconds, we update this trade and set the quantity to 200.

Depending on when the tick happens, you could either get two updates:

```
|---- gathering phase ----|
*
*
*
*
* insert (qty 100)
|---- flushing phase -----|
* aggregate updates
* publish updates insert (qty 100)
|---- gathering phase ----|
* modify (qty 200)
*
*
*
*
|---- flushing phase -----|
* aggregate updates
* publish updates modify (qty 200)
|---- gathering phase ----| (batching period)
*
*
```

1. Insert trade, qty = 100
2. Modify trade, qty = 200

Or you could receive a single update:

```
|---- gathering phase ----|
*
*
*
* insert (qty 100)
* modify (qty 200)
|---- flushing phase -----|
* aggregate updates
* publish updates insert (qty 200)
```

1. Insert trade, qty = 200

Depending on timing, either case is possible, and the smaller the gap between the insert and modify, the more likely the second scenario becomes.
However, even if these operations happen immediately after each other, we could still receive two updates.

When we get two updates of the same record within the batching interval we will always aggregate the updates.
This could even mean that updates will be disregarded all together, for example if we receive an insert and a delete within the batching interval.

This will always be non-deterministic, as we don't provide any guarantees.

#### Batching at different levels

The other thing to note is that batching happens on both the data server and the update queue level.
We batch on the queue level to minimise the amount of work the data server has to do.
Because we pre-allocate LMDB when the data sever starts, having too many needless updates would eat into that allocation.
We batch on the data server to minimise the load on the client and the connection.

### Out of sequence updates on the queue

Updates are published on update queue once a record has been written to the database, or when a transaction completes if we're in a transaction.
Within a multi-node setup, updates are published locally and forwarded to other nodes in genesis-cluster. Because of this forwarding, we can receive updates out of sequence.
For example we insert our trade on node 1, and then modify it on node 2. On node 2 we might receive the modify before the insert update.
As the insert updates has to be forwarded from node 1.

This means that when listening to updates on tables, in these setups, with high message volume, we should check the timestamp against the latest received update to make sure we are not receiving updates out of sequence.

For views this is not a problem, as we will refresh the record from the database within a transaction to make sure the update we publish is valid.

