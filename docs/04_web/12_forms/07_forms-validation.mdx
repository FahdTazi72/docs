---
title: 'Foundation Forms - Validation'
sidebar_label: 'Validation'
id: foundation-forms-validation
keywords: [genesis, foundation, ui, forms, smart forms]
tags:
  - genesis
  - foundation
  - ui
  - forms
  - smart forms
---

# Foundation Forms - Validation

You can apply simple and more complex validation logic to foundation forms in a number of ways.

## Required fields - Frontend

To make a field required you include the field name in the json schema `required` property.

In this example we extend our past example schema with the required fields.

```ts
const requiredFieldsJsonSchema: JSONSchema7 = {
  ...singleColumnJsonSchema,
  required: [ 'side', 'stockSymbol', 'quantity', 'price']
}

```

If you focus and blur, or try submitting the form with the fields not filled you will see the error messages. Also, the form label will be appended with a `*` to indicate it is required.

![Validation required](/img/smart-forms/validation-required.png)


## Required fields - auto generated schema from backend

If you are using `reseourceName` property on your form the form will use the generated json schema from the corresponding type.

Using the `EVENT_COUNTERPARTY_INSERT` event endpoint your template looks like this e.g. just passing the event name.

```ts
<foundation-form resourceName="EVENT_COUNTERPARTY_INSERT">
</foundation-form>
```

This is based on the model defined in your tables and event handler files file. The `notNull()` fields will be required in the form.

```kts
eventHandler<Counterparty>("COUNTERPARTY_INSERT", transactional = true) {
    onCommit { event ->
        val details = event.details
        entityDb.insert(details)
        ack()
    }
}
```

You will see an autogenerated form. Remember, you can override the appearance using the `uiSchema` attribute on the `foundation-form` element.

```kts
...
table(name = "COUNTERPARTY", id = 11_001) {
    field("COUNTERPARTY_ID", INT).notNull()
    field("ENABLED", BOOLEAN).default(false).notNull()
    field("MAIN_CONTACT", STRING).notNull()
    field("NAME", STRING).notNull()
    primaryKey("COUNTERPARTY_ID")
}
...
```

![Validation required](/img/smart-forms/validation-required-backend.png)

## Min Length, Max Length

A common pattern in a form field is to have a minimum or maximum number of characters, or a min or max value. This is easily achieved using the json schema.

You specify the `minLength` or `maxLength` property for an individual schema element

```ts
export const validationMinMaxLengthJsonSchema: JSONSchema7 = {
  properties: {
    minLengthInput: {
      type: 'string',
      minLength: 3,
    },
    maxLengthInput: {
      type: 'string',
      maxLength: 10,
    }
  },
  required: [ 'minLengthInput', 'maxLengthInput']
}
```

Then your form will validate the number of characters.

![Validation required](/img/smart-forms/validation-min-max-length.png)

## Min Value, Max Value

Another common pattern in a form field is to have a minimum or maximum value. Again, this is easily achieved using the json schema.

You specify the `minimum` or `maximum` property for an individual schema element


```ts
export const validationMinMaxValueJsonSchema: JSONSchema7 = {
  properties: {
    minValueInput: {
      type: 'number',
      minimum: 18,
    },
    maxValueInput: {
      type: 'number',
      maximum: 65,
    }
  },
  required: [ 'minValueInput', 'maxValueInput']
}
```

The form will show any errors if you try to submit or blur an element.

![Validation required](/img/smart-forms/validation-min-max-value.png)
