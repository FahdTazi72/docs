---
title: 'How to manage nested objects'
sidebar_label: 'Manage nested objects'
id: ht-nested-objects
keywords: [nested objects]
tags:
    - nested objects

---



import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Nested objects
Nested objects are common features of applications.  For example, a __Swap Trade__ has multiple __Legs__, each with multiple
__Cashflows__ and each __Cashflow__ can have multiple __Fixings__.

For the example here we will use a __Counterparty Group__ which
can contain 1 or more __Subsidiaries__.  Each __Subsidiary__ can contain 1 or more __Contacts__.

In the context of this explanation a __Swap Trade__ and a __Counterparty Group__ are both examples of __Nested Objects__.

Often it is desirable, or necessary, to modify a nested object as an atomic action, rather than changing the individual objects separately.

Genesis supports this capability.  From Genesis Create you automatically get the ability to modify the individual objects.  To change
this to an atomic change of the nested object we simply need to declare a Data Access Object (DAO) and pass this to events
and allow this to be served via a Request Response (reqrep).  Optionally we will want to remove the events relating to the individual
objects from projects created by Genesis Create.

To create a DAO representation we define a file in app/src/main/kotlin such as Message.kt:
```jsx
data class CounterpartyDAO(
    val counterpartyId: String? = null,
    val counterparty: String,
    val subsidiaries: List<SubsidiaryDao>? = null
)

data class SubsidiaryDao(
    val subsidiaryId: String? = null,
    val subsidiaryName: String,
    val contacts: List<SubsidiaryContactDao>? = null
)

data class SubsidiaryContactDao(
    val contactId: String? = null,
    val contactName: String,
    val contactPhone: String
)
```

These DAO's can then be passed into events and be returned by a reqrep.  For example, the event handler would be declared thus:
```jsx
eventHandler {
  eventHandler<CounterpartyDAO>("INSERT_COUNTERPARTY", transactional = true) {
    onCommit { event ->
      val request = event.details
      ...
      }
      ack()
    }
}
```
Within the event handler it is necessary to cycle through the nested object to perform appropriate checks and save all data.
The example application, __here !need link!__, demonstrates this.

To request the data back a reqrep is needed.  This would be declared as:
```jsx
requestReplies {
  requestReply<CounterpartyGroup.ById, CounterpartyDAO>("FULL_COUNTERPARTY_GROUP") {
    replySingle { request ->
        ...
    }
  }
}
```
Within the reqrep we need to load the full nested object.  The example application, __here !need link!__, demonstrates this.

## Front End Configuration
This is much harder and Patrick is taking a look next week...
Basic front end works, but looks horrendous!  Defo need Patrick magic first!

## Testing

:::info
Go to our [**Testing**](/how-to/ht-prepare-test/) page for details of our testing tools and the dependencies that you need to declare.
:::

To test your auth set-up  on your app:

- *Details to follow shortly. Thank you for your patience.*


