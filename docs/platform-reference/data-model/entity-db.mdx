---
title: 'EntityDb Api Reference'
sidebar_label: 'EntityDb Api Reference'
sidebar_position: 2
id: entity-db
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The entity db allows developers to interact with the database layer; using any of the generated type-safe entities, for
both tables and views. The interface supports the same operations as the generated repositories, but will accept any
entity. It supports read operations for views and tables and write operations for tables only.

The entity db differs from the generated repositories, in that it can handle any table and most view entities and
it differs from `RxDb` in that all operations are type safe.

As with the generated repositories, there are two flavours of the entity db, one supports RxJava signatures, where
return types are either `Maybe`, `Single` or `Flowable`, this will be the entity db to use from Java.

The other flavour supports Kotlin coroutines, and instead of `Maybe` and `Single` there are `suspend` functions that
return either nullable or non-nullable values, depending on the operation. Instead of `Flowable` this implementation
returns kotlin native `Flow`.

The entity db is available in the kotlin event handler. Like `RxDb` it can also be injected in java and kotlin
classes using `AsyncEntityDb` or `RxEntityDb`.

When referring to indices in the database operations, the database accepts _index classes_ or _entity class_
in combination with _index references_. For comparison:

```kotlin
db.get(trade, Trade.ById)
//vs 
db.get(Trade.ById("TR_123"))
```

## Supported operations

* Read Operations:
    * `get`
    * `getAll`
    * `getAllAsList`
    * `getBulk` / `getBulkFromEnd`
    * `getRange` / `getRangeFromEnd`
* Write operations
    * `insert` / `insertAll`
    * `modify` / `modifyAll`
    * `upsert` / `upsertAll`
    * `delete` / `deleteAll`
* Transactions
    * readTransaction
    * writeTransaction
* Subscribe operation
    * `subscribe`
    * `bulkSubscribe`
    * `rangeSubscribe`

## Entity Types

The entity database uses generated table and view entity types and indexes to perform type safe operations on the
database.

On views the indices of the root table will become indices if:

1. the index is the primary key
2. the first field of the index used in the view

If a view has any one to many joins, then all unique indices, including the primary key will get downgraded to a
non-unique index.

Please note that the examples below for kotlin will use the `AsyncEntityDb` whereas the java examples will use
the `RxEntityDb` type. The `AsyncEntityDb` is only available through kotlin, the `RxEntityDb` however can be
used in both java and kotlin.

For this document we will use the following table definition as our base:

```kotlin
tables {
    table("TRADE", 1100) {
        TRADE_ID
        TRADE_TYPE
        TRADE_DATE
        primaryKey {
            TRADE_ID
        }
        indices {
            unique {
                TRADE_TYPE
                TRADE_ID
            }
            nonUnique {
                TRADE_DATE
            }
        }
    }
}
```

This will have the following index types:

* Trade.ById
* Trade.ByTypeId
* Trade.ByDate

## Type convention

| Type                               | Meaning                           | Example        |
|------------------------------------|-----------------------------------|----------------|
| `E`                                | A table or view entity            | `Trade`        |
| `T`                                | A table entity                    | `Trade`        |
| `V`                                | A view entity                     | `TradeView`    |
| `EntityIndex<E>`                   | An index of E                     | `Trade.ById`   |
| `UniqueEntityIndex<E>`             | A unique index of E               | `Trade.ById`   |
| `NonUniqueEntityIndex<E>`          | A non unique index of E           | `Trade.ByDate` |
| `EntityIndexReference<E>`          | An index reference of E           | `Trade.ById`   |
| `UniqueEntityIndexReference<E>`    | A unique index reference of E     | `Trade.ById`   |
| `NonUniqueEntityIndexReference<E>` | A non unique index reference of E | `Trade.ByDate` |
| `F<E>`                             | The full table /view name for E   | `TRADE`        |
| `Class<E>`                         | The class reference for E         | `Trade.class`  |
| `KClass<E>`                        | The kotlin class reference for E  | `Trade::class` |

## Read Operations

### get

Get is a simple lookup on the database; it will return a single entity if a match is found or no records if none is
found.

The following overloads exists for get, fields is a `Set<String>`.

1. `get(E, EntityIndexReference<E>, fields) : E?`
2. `get(E, fields) : E?`
3. `get(E, EntityIndexReference<E>) : E?`
4. `get(UniqueEntityIndex<E>, fields) : E?`
5. `get(UniqueEntityIndex<E>) : E?`

#### Syntax

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// we can look up trades by passing in a unique index class:
val trade = db.get(Trade.byId("TRADE_1"))

// a trade object with the primary key set 
val trade = db.get(trade)

// a trade object and a reference to unique index
val trade = db.get(trade, Trade.ByTypeId)

// or you can access the index class from the entity
val trade = db.get(trade.byTypeId())
```

</TabItem>
<TabItem value="java">

```java
// we can look up trades by passing in a unique index class:
final var trade = db.get(Trade.byId("TRADE_1"))
        .blockingGet();

// a trade object with the primary key set 
final var trade = db.get(trade)
        .blockingGet();

// a trade object and a reference to unique index
final var trade = db.get(trade,Trade.ByTypeId.Companion)
        .blockingGet();

// or you can access the index class from the entity
final var trade = db.get(trade.byTypeId())
        .blockingGet();
```
</TabItem>
</Tabs>

### getAll

Get all will take multiple _unique_ index class instances and return the type entity type for record. It takes
a `List<Pair<String, NonUniqueEntityIndex<E>>>`, where the `String` is a unique reference to each request.

#### Overloads

1. `getAll(requestDetails: Flow<Pair<String, UI<E>>): Map<String, E?>`
2. `getAll(requestDetails: List<Pair<String, UI<E>>): Map<String, E?>`

```kotlin
val map = db.getAll(listOf("A" to Trade.byId("TRADE_A"), "B" to Trade.byId("TRADE_B")))

val recordA = map["A"]
val recordB = map["B"]
```

### getAllAsList

This operation is similar to the above, but takes a `List<NonUniqueEntityIndex<E>>`, and will return a `List<E?>`,
the results are returned in the same order they were requested and will be `null` if no record was found. The result
list is guaranteed to be the same count as the input.

#### Overloads

1. `getAllAsList(Flow<UI<E>>): List<E?>`
2. `getAllAsList(List<UI<E>>): List<E?>`
3. `getAllAsList(vararg UI<E>): List<E?>`

```kotlin
val list = db.getAllAsList(Trade.byId("TRADE_A"), Trade.byId("TRADE_B"))

val recordA = list[0]
val recordB = list[1]
```

### getBulk

Get bulk will create a `Flow` or `Flowable` of the whole table. If the database layer supports it, these will be
sorted in ascending order by the provided index or by the primary key if none is provided. Currently, only
FoundationDb and Postgres support an ordered `getBulk`. There are also `getBulkFromEnd` function which will
return records in descending order. There are also a number of continuation operations, which will return
the whole table after the provided record.

#### Overloads

1. `getBulk<E>(): Flow<E>` (kotlin only)
2. `getBulk([Class<E> /  KClass<E>]): Flow<E>`
3. `getBulk(UR<E>): Flow<E>`
4. `getBulk(UR<E>, fields): Flow<E>`
5. `getBulk(UR<E>, E, fields): Flow<E>` (continuation)
6. `getBulkFromEnd(UR<E>): Flow<E>`
7. `getBulkFromEnd(UR<E>, E), E: Flow<E>` (continuation)
7. `getBulkFromEnd(UR<E>, E, fields), E: Flow<E>` (continuation)
8. `getBulkFromEnd(UR<E>, fields): Flow<E>`

#### Syntax

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// we can pass in Trade as a type parameter
val flow = db.getBulk&lt;Trade>()
// we can pass in the TRADE object
val flow = db.getBulk(TRADE)
// or we can pass in an index reference
val flow = db.getBulk(Trade.ByTypeId)
```

</TabItem>
<TabItem value="java">

```java
// we can pass in Trade as a type parameter
final var flowable = db.getBulk(Trade.class);
// we can pass in the TRADE object
final var flowable = db.getBulk(TRADE.INSTACE);
// or we can pass in an index reference
final var flowable = db.getBulk(Trade.ById.Companion);
```
</TabItem>
</Tabs>

### getRange

Whereas a `get` operation selects for a single entry from a unique index, and a `getBulk` operation selects the whole
table, `getRange` selects a range within an index. For example to select all trades by a single currency. There
are a number of ways a range can be specified:

1. A non-unique index entry.
2. A range between two index entries.
3. When an index has more than one column, part of the index starting from the first column.

When selecting on part of an index, the number of columns can be specified using the `numKeyFields` parameter. The fields
are always selected in the order they are specified in the index.

There are 15 different get range functions. The records will be returned in ascending order, apart from when using
the `fromEnd` functions, in which case the records will be returned in descending order. The `numKeyFields` property
specifies the number of fields to use from an index. For example in the `TRADE` example there is the `TRADE_BY_TYPE_ID`
index. If we pass in 1 for `numKeyFields` the range will return records by `TRADE_TYPE` the first column in that index.

#### Overloads

1. `getRange(E, EntityIndexReference<E>, numKeyFields): Flow<E>`
2. `getRange(E, EntityIndexReference<E>, numKeyFields, fields): Flow<E>`
3. `getRange(E, E?, EntityIndexReference<E>, numKeyFields): Flow<E>`
4. `getRange(E, E?, EntityIndexReference<E>, numKeyFields, fields): Flow<E>`
5. `getRange(EntityIndex<E>, numKeyFields): Flow<E>`
6. `getRange(EntityIndex<E>, numKeyFields, fields): Flow<E>`
7. `getRange(NonUniqueEntityIndex<E>, NonUniqueEntityIndex<E>): Flow<E>`
8. `getRange(NonUniqueEntityIndex<E>): Flow<E>`
9. `getRange(NonUniqueEntityIndex<E>, fields): Flow<E>`
10. `getRange(EntityIndex<E>, EntityIndex<E>, numKeyFields): Flow<E>`
11. `getRange(EntityIndex<E>, EntityIndex<E>, numKeyFields, fields): Flow<E>`
12. `getRangeFromEnd(E, E, EntityIndexReference<E>, numKeyFields, fields): Flow<E>`
13. `getRangeFromEnd(E, E, EntityIndexReference<E>, numKeyFields): Flow<E>`
14. `getRangeFromEnd(EntityIndex<E>, EntityIndex<E>, numKeyFields, fields): Flow<E>`
15. `getRangeFromEnd(EntityIndex<E>, EntityIndex<E>, numKeyFields): Flow<E>`

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// there are multiple ways to get a range of records, either for some fields
// of a unique index or some or all fields of a non unique index:
db.getRange(Trade.byTypeId("typeA"))
db.getRange(trade.byTypeId(), 1)
db.getRange(trade, Trade.ByTypeId, 1)

// or by setting a start and an end range:
db.getRange(Trade.byTypeId("tradeType1"), Trade.byTypeId("tradeType2"))
db.getRange(trade1.byTypeId(), trade2.byTypeId(), 1).toList()
db.getRange(trade1, trade2, Trade.ByTypeId, 1).toList()
```

</TabItem>
<TabItem value="java">

```java
// there are multiple ways to get a range of records, either for some fields
// of a unique index or some or all fields of a non unique index:
db.getRange(Trade.byTypeId("typeA"));
db.getRange(trade.byTypeId(),1);
db.getRange(trade,Trade.ByTypeId.Companion,1);

// or by setting a start and an end range:
db.getRange(Trade.byTypeId("tradeType1"),Trade.byTypeId("tradeType2"));
db.getRange(trade1.byTypeId(),trade2.byTypeId(),1).toList();
db.getRange(trade1,trade2,Trade.ByTypeId.Companion,1).toList();
```
</TabItem>
</Tabs>

## Write Operations

All write operations have versions that take a single entity and versions that take multiple entries. The return values
for these operations are type safe (see details below), provided all entries are of the same type. For example, when
inserting multiple `Trade` entries, the return type will be `List<InsertResult<Trade>>`. Different entity types can be
inserted in the same operation, however, the return type will be `List<InsertResult<Entity>>`. Also, modify operations
only accept table entities.

### Default and generated values

When writing a record to the database, typically all non null properties should be set on the entity. An entity property
becomes non-nullable if:

1. It has a default value
2. It is generated by the database, i.e. sequence or auto increment fields
3. The column is included in an index or is specifically declared not null in the schema

#### Default values

Properties with a default value, will have the value set by default unless set explicitly in the builder.

#### Generated properties

Generated properties will be left in an indeterminate state if not set in the builder. When writing to the
database, this indeterminate state will be set in the return value. Trying to read the property while it is
in this will result in an `IllegalArugmentException`. Each generated property will have two read only
associated properties to access these properties in a safe manner. These will be a `is[FieldName]Generated`
boolean property and a `[fieldName]OrNull` property.

For example:

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
// tradeId is generated
trade.tradeId                   // will cause an exception if not initialised
trade.tradeIdOrNull             // will return the tradeId if set, or else null
trade.isTradeIdInitialised      // will return true if set
```

</TabItem>
<TabItem value="java">

```java
// tradeId is generated
trade.getTradeId();             // will cause an exception if not initialised
trade.getTradeIdOrNull();       // will return the tradeId if set, or else null
trade.isTradeIdInitialised();   // will return true if set
```
</TabItem>
</Tabs>

#### Columns in Indices or are not null explicitly

Columns in indices or declared not null should always be set in a builder, unless it has a default value or is a
generated column. In all other instances a `NullPointerException` will be thrown when building the object.

### Insert

This will insert a new record into the database. The `insert` function takes a single table entity. The `insertAll`
function takes multiple records, and has several overloads:

#### Overloads

1. `insert(E): InsertResult<E>`
2. `insertAll(vararg E): List<InsertResult<E>>`
3. `insertAll(List<E>): List<InsertResult<E>>`
4. `insertAll(Flow<E>): List<InsertResult<E>>`

### Modify

This will try to modify a record in the database, if the record does not exist, an error will be thrown.

#### Overloads

1. `modify(EntityModifyDetails<E>): ModifyResult<E>`
2. `modify(E): ModifyResult<E>`
3. `modify(E, UniqueEntityIndexReference<E>): ModifyResult<E>`
4. `modifyAll(vararg E): List<ModifyResult<E>>`
5. `modifyAll(vararg EntityModifyDetails<E>): List<ModifyResult<E>>`
6. `modifyAll(List<EntityModifyDetails<E>>): List<ModifyResult<E>>`
7. `modifyAll(Flow<EntityModifyDetails<E>>): List<ModifyResult<E>>`

### Upsert

This will try to modify a record in the database, if the record does not exist, the record will be inserted instead.

#### Overloads

1. `upsert(EntityModifyDetails<E>): UpsertResult<E>`
2. `upsert(E): UpsertResult<E>`
3. `upsertAll(vararg E): List<UpsertResult<E>>`
4. `upsertAll(vararg EntityModifyDetails<E>): List<UpsertResult<E>>`
5. `upsertAll(List<EntityModifyDetails<E>>): List<UpsertResult<E>>`
6. `upsertAll(Flow<EntityModifyDetails<E>>): List<UpsertResult<E>>`

### Delete

This will try to delete a record

#### Overloads

1. `delete(E): DeleteResult<E>`
1. `delete(UniqueEntityIndex<E>): DeleteResult<E>`
2. `deleteAll(vararg E): List<DeleteResult<E>>`
2. `deleteAll(vararg UniqueEntityIndex<E>): List<DeleteResult<E>>`
3. `deleteAll(List<E>): List<DeleteResult<E>>`
4. `deleteAll(Flow<E>): List<DeleteResult<E>>`

## Transactions

If the underlying database supports transactions, then the entity db provides type safe access to these. A
read-transaction will support the same read operations as the entity db, and a write-transaction will support the same
read and write operations. If a write-transaction fails all operations will be reverted. Subscribe operations are not
supported within transactions.

Currently, this is supported when using **FoundationDb** and **Postgresql**.

One distinction between kotlin and java here is that when using kotlin, the transaction is the receiver in
the `readTransaction` call. This means that within the block `this` refers to the transaction. In the java world, the
transaction is the first parameter of the lambda.

### Read Transactions

Read transactions ensure all read operations are consistent and intervening writes will not affect reads within the
transaction. The return value in the transaction will also be returned from the transaction. For the `RxEntityDb` it
will be a `Single<*>`.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val orderTrade = db.readTransaction {
    val trade = get(Trade.byId("TR_123"))
    val order = get(Order.byId(trade.orderId))
    buildOrderTrade(order, trade)
}
```

</TabItem>
<TabItem value="java">

```java
Single<OrderTrade> oderTrade = db.readTransaction(transaction -> {
    final var trade = transaction.get(Trade.byId("TR_123")).blockingGet();
    final var order = transaction.get(Order.byId(trade.orderId)).blockingGet();
    return buildOrderTrade(order, trade);
});
```
</TabItem>
</Tabs>

### Write Transaction

Write transactions ensure all read and write operations are consistent, furthermore, if any exception bubbles up to the
transaction level, all writes are rolled back. The `writeTransaction` will return
a `Pair<T, List<EntityWriteResult<*>>>` where `T` is the value returned in the `writeTransaction` lambda.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val (orderId, writeResults) = db.writeTransaction {
    insert(trade)
    val orderInsert = insert(order)
    orderInsert.record.orderId
}
```

</TabItem>
<TabItem value="java">

```java
final var pair = db.writeTransaction(transaction -> {
    insert(trade).blockingGet();
    final var orderInsert = insert(order).blockingGet();
    return orderInsert.getRecord.getOrderId();
}).blockingGet();
final var orderId = pair.getFirst();
final var writeResults = pair.getSecond();
```
</TabItem>
</Tabs>

## Subscribe Operations

### Subscribe

Subscribe starts a database listener that will receive updates to tables or views. When subscribing to view updates,
only updates to the root table will be published. Further, if the view has any inner joins, the published update will
not necessarily reflect the underlying operation. A `ModifyResult` might be transformed into an `InsertResult` if the
new record returns the in the inner join and the previous value did or conversely, it might get transformed into a
`DeleteResult` in the reverse scenario.

Subscribe supports the following parameters:

1. `delay`: `Int` the listener will batch updates every x milliseconds
2. `fields`: `Set<String>` filters `ModifyResult` on fields
3. `subscribeLocally`: `Boolean` only publish updates local to the node

### Overloads

The rx entity db takes a `Class<E>`, whereas the async entity db takes a `KClass<E>`.
Parameters marked with an asterisk(*) are optional.

1. `subscribe([KClass<E> / Class<E>], delay*, fields*, subscribeLocally*): Flow<E>`

These functions are available in kotlin only:

2. `subscribe<E>(delay*, fields*, subscribeLocally*): Flow<E>`

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val subscription = launch {
    db.subscribe<Trade>()
        .collect { update ->
            println("Received a trade update! $update")
        }
}
```

</TabItem>
<TabItem value="java">

```java
final var subscription = db.subscribe(Trade.class)
        .subscribe(update -> {
            System.out.println("Received a trade update! " + update);
        });
```
</TabItem>
</Tabs>

### Bulk Subscribe

The `bulkSubscribe` combines a `getBulk` and a `subscribe` call into a single function. This operation is useful when
a class needs to read a full table and keep updated of changes to the underlying table or view. The further benefit
of this is that this operation also support backward joins for views. This means that it can receive updates of the
root table as well as joined tables. The view needs to support this in the definition and it will need to be enabled
on the `bulkSubscribe` call.

`bulkSubscribe` supports the following parameters:

1. `delay`: `Int` the listener will batch updates every x milliseconds
2. `fields`: `Set<String>` filters `ModifyResult` on fields
3. `index`: `UniqueEntityIndex<E>` the index to use for the `getBulk` part of the call
4. `subscribeLocally`: `Boolean` only publish updates local to the node
5. `backwardJoins`: `Boolean` enable backward joins in views

#### Overloads

Parameters marked with an asterisk(*) are optional

1. `bulkSubscribe([Class<E> / KClass<E>], fields*, delay*, index*, subscribeLocally*, backwardJoins*) : Flow<Bulk<E>>`

These functions are available in kotlin only:

2. `bulkSubscribe<E>(fields*, delay*, index*, subscribeLocally*, backwardJoins*) : Flow<Bulk<E>>`

### Range Subscribe

Range subscribe is like bulk subscribe, but it combines a `getRange` with `subscribe`. This operation is useful when
a class needs to read part of a table or view and keep updated of changes. The range will be applied to the `subscribe`
as well. As such, the update type will reflect whether a row comes into the range or moves out of the range, rather
than what happened in the database. This means that a `ModifyResult<E>` might be converted to an `InsertResult<E>` or a
`DeleteResult<E>`.

Furthermore, `rangeSubscribe` can take a static range, for example all USD trades, or a dynamic range, all trades booked
within the last 2 hours. The dynamic range will be updated on a schedule, either at an interval or at a time.

#### Overloads

`rangeSubscribe` supports the following parameters:

1. `delay`: `Int` the listener will batch updates every x milliseconds
2. `numKeyFields`: `Int` the number of key fields to take into account for the range
3. `fields`: `Set<String>` filters `ModifyResult` on fields
4. `index`: `UniqueEntityIndex<E>` the index to use for the `getBulk` part of the call
5. `subscribeLocally`: `Boolean` only publish updates local to the node
6. `backwardJoins`: `Boolean` enable backward joins in views
7. `updateFrequency`: `PalDuration` a schedule for updating dynamic ranges
8. `rangeProvider`: `() -> EntityIndex<E>` a lambda providing a `EntityIndex<E>`, for use in dynamic ranges

Static range
1. `rangeSubscribe(from: EntityIndex<E>, to: EntityIndex<E>, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>`
2. `rangeSubscribe(EntityIndex<E>, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>`
3. `rangeSubscribe(rangeProvider, rangeProvider, updateFrequency, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>`
4. `rangeSubscribe(rangeProvider, updateFrequency, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>`

## Entity Reference

### Generated Entity Class

Generated _entity classes_ are classes that represent a single row in table or a view. In our example `Trade`. Instances
of these classes can be used in some database operations as inputs, and most often included in the output. _Entity
classes_ have associated index types.

Entity classes will have properties for all the fields associated with the table, as well as helper methods to get index
classes. The entity classes also have builders that help build the entities.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val trade = Trade {
    tradeId = "TR_123"
    tradeType = "SWAP"
    tradeDate = now()
}

val id = trade.tradeId
val newTrade = trade.copy(tradeType = "NDS_SWAP")
val tradeById = trade.byId()
```

</TabItem>
<TabItem value="java">

```java
final var trade = Trade.builder()
        .setTradeId("TR_123")
        .setTradeType("SWAP")
        .setTradeDate(now())
        .build();

final var id=trade.getTradeId();

final var newTrade = trade.toBuilder()
        .setTradeType("NDS_SWAP")
        .build();

final var byId = trade.byId();
```
</TabItem>
</Tabs>

### Generated Index Class

Generated _index classes_ are nested inside the _entity classes_, for each index a class is generated. In our
`TRADE` example we have `Trade.ById`, `Trade.ByTypeId` and `Trade.ByDate`. Instances of these classes can be used as
input in some database operations. The database distinguishes between _unique_ and _non-unique_
indices. In some cases, the database only accepts _unique_ indices, and in other cases it will accept either.

When building index classes, not all fields need to be provided, however the fields should always be listed in order.
Also, a unique index will turn into a non-unique index if not all fields are provided.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val byId = Trade.byId("TR_123")
val byDate = Trade.byDate(now())
val byTypeId = Trade.byTypeId("SWAP", "TR_123")
val byType = Trade.byTypeId("SWAP")
```

</TabItem>
<TabItem value="java">

```java
final var byId = Trade.byId("TR_123");
final var byDate = Trade.byDate(now());
final var byTypeId = Trade.byTypeId("SWAP","TR_123");
final var swap = Trade.byTypeId("SWAP");
```
</TabItem>
</Tabs>

### Generated Index Reference

Generated _index references_ have the same name as the _index classes_, but are used as a reference to a specific index,
rather than an index row. As with the _index classes_ the database distinguishes between
_unique_ and _non-unique_ index references.

## Write result reference

The entity database will return type safe results for write operations. There are 4 main write results, one for each of
the type of write operations. In all cases the records in these result will be a generated entity that matches the
input. So for inserting a `Trade` instance the database will return an result of type `InsertResult<Trade>` where the
property `record` will be of type `Trade`.

1. `InsertResult`
3. `DeleteResult`
2. `ModifyResult`
4. `UpsertResult`; either a `InsertResult` or a `ModifyResult`

### InsertResult

The `InsertResult` has a single property `record` which is the inserted record and includes any generated values.

### DeleteResult

The `DeleteResult` has a single property `record` which is the record as it was in the database before it was deleted.

### ModifyResult

The `ModifyResult` is slightly more complex, it has a `record` property, which is the record in the database after
the modify operation. There is also a `previous` property, which is the record as it was prior to the modify operation.
Finally, there is a `modifiedFieds` property, which holds a `Set<String>` of the fields that were changed in the modify.

## Record Update Reference

When subscribing to database updates using the entity db, updates are provided in a type safe manner. All update types
have the same super class, `GenericRecordUpdate<E>`, where `E` is the entity type. Using the entity db, developers can
subscribe to table and view updates. There are three different update subtypes, one of each the update operations:

1. `GenericRecordUpdate.Insert`
2. `GenericRecordUpdate.Delete`
3. `GenericRecordUpdate.Modify`

Each one of these has the following properties:

1. `tableName`: `String`
6. `recordId`: `Long`
7. `timestamp`: `Long`
8. `emitter`: `String?`

When subscribing to view updates, the update listener will listen to updates on the root table. Also, the update type
will be based on whether the record is shown in the view or not. For example, if after a modify operation a row is no
longer visible in the view due to a inner join, the view subscriber will receive the update as a delete, rather than a
modify.

## Bulk Reference

Bulk objects are returned to `bulkSubscribe` and `rangeSubscribe` listeners and are a concatenation of a read and a
normal `subscribe` operation. The bulk type has the following hierarchy, where every instance is one of the subtypes,
so `Bulk` is either `Bulk.Prime` or `Bulk.Update` and `Bulk.Prime` is either `Bulk.Prime.Record`
or `Bulk.Prime.Complete`.

1. `Bulk`
    1. `Bulk.Prime`
        1. `Bulk.Prime.Record`
        2. `Bulk.Prime.Complete`
    2. `Bulk.Update`
        1. `Bulk.Update.Insert`
        2. `Bulk.Update.Delete`
        3. `Bulk.Update.Modify`

A bulk flow will always follow this sequence:

1. 0 or more `Bulk.Prime.Record`
2. 1 `Bulk.Prime.Complete`
3. 0 or more `Bulk.Update` subtypes

## EntityModifyDetails Reference

When performing modify and upsert operations, it becomes necessary to specify the index to use to identify the record to
modify and which fields to modify. For this there is the `EntityModifyDetails` class.

<Tabs defaultValue="kotlin" values={[{ label: 'Kotlin', value: 'kotlin', }, { label: 'Java', value: 'java', }]}>
<TabItem value="kotlin">

```kotlin
val modifyDetails = EntityModifyDetails(trade)
// or
val modifyDetails = EntityModifyDetails(trade, Trade.ByTypeId)
// or
val modifyDetails = EntityModifyDetails(trade, Trade.ByTypeId, listOf("TRADE_ID"))
```

</TabItem>
<TabItem value="java">

```java
final var modifyDetails = EntityModifyDetails.newInstance(trade)
// or
final var modifyDetails = EntityModifyDetails.newInstance(trade, Trade.ByTypeId.Instance)
// or
final var modifyDetails = EntityModifyDetails.newInstance(trade, Trade.ByTypeIdInstance, listOf("TRADE_ID"))
```
</TabItem>
</Tabs>