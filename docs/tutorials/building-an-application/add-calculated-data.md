---
id: add-calculated-data
title: Add calculated data
sidebar_label: Add calculated data
sidebar_position: 4

---
At this point, we have a data model that serves both the reference database and the trading database, Our trading application has  a schema for the TRADE table, and it has event handlers, data servers and request servers.

Now we want to add calculations to add position-keeping. In brief you need to:

1. Create some new fields for the position-keeping information.
2. Create a new table for displaying the information.
3. Define the logic that calculates the positions in a new consolidator file.
4. Update the system files to incorporate the new consolidator.

## 1. Define the new fields

Before we create the new POSITION table, we need to create some new fields. Edit the fields file, which is **trading_app-fields-dictionary.kts**.

Add these 5 fields:

* POSITION_ID (this can be an autogenerated sequence, so declare it as such) : STRING
* INSTRUMENT_ID : STRING
* COUNTERPARTY_ID : STRING
* QUANTITY: LONG (total number of shares)
* NOTIONAL: DOUBLE (instrument price multiplied by quantity)

    // Position
     field(name = "POSITION_ID", type = STRING)
     field(name = "INSTRUMENT_ID", type = STRING)
     field(name = "COUNTERPARTY_ID", type = STRING)
     field(name = "QUANTITY", type = LONG)
     field(name = "NOTIONAL", type = DOUBLE)

The instrument price table needs at least two fields:

* INSTRUMENT_ID : STRING
* LAST_PRICE: DOUBLE

![](/img/fields-for-the-instrument-name-table.png)

Once you have defined the fields, run the following tasks in maven:

1. **generateSysDef**
2. **generateFields**

This applies the new fields  to **-tables-dictionary.kts**.

## 2. Add the primary keys and indices for each table

## Add the primary keys

* POSITION_ID is the primary key  (**primaryKey**) for the POSITION table.
* instrument id is the primary key (**primaryKey**) for the INSTRUMENT_PRICE, INSTRUMENT_ID and COUNTERPARTY_ID tables.

![](/img/keys-and-indices.png)

    table(name = "POSITION", id = 11001) {
     sequence(POSITION_ID, "PS") //autogenerated sequence
     INSTRUMENT_ID
     COUNTERPARTY_ID
     QUANTITY
     NOTIONAL
     primaryKey {
     POSITION_ID
     }
     indices {
     unique {
     INSTRUMENT_ID
     COUNTERPARTY_ID
     }
     nonUnique {
     COUNTERPARTY_ID
     }
     }
     }

## Add the indices

* nonunique indices for the POSITION table
* unique index for the INSTRUMENT_ID and COUNTERPARTY_ID tables (This enables you to do a lookup in consolidator.)

## 3. Define the position-keeping logic in the consolidator

Define a **trading_app-consolidator2.xml** file inside **trading_app-config/src/main/resources/cfg**. This is where you define the consolidator logic.

The consolidator is going to increase or decrease the quantity for POSITION records, based on the TRADE table updates. It also needs to calculate the new notional.

    <consolidations>
     <consolidation name="CONSOLIDATE_POSITIONS" start="true">
     <tables>
     <table name="TRADE" alias="t" seedKey="TRADE_BY_ID" consolidationFields="QUANTITY PRICE"/>
     <table name="INSTRUMENT_PRICE" alias="ip" >
     <join key="INSTRUMENT_PRICE_BY_INSTRUMENT_ID">
     <![CDATA[
     ip.setString("INSTRUMENT_ID", t.getString("INSTRUMENT_ID"))
     ]]>
     </join>
     </table>
     </tables>
     <groupBy>
     <![CDATA[
     group(t.getString("INSTRUMENT_ID"), t.getString("COUNTERPARTY_ID"))
     ]]>
     </groupBy>
     <consolidateTable name="POSITION" alias="p" consolidationFields="QUANTITY NOTIONAL"
     transient="true">
     <consolidationTarget key="POSITION_BY_INSTRUMENT_ID_COUNTERPARTY_ID">
     <![CDATA[
     p.setString("COUNTERPARTY_ID", t?.getString("COUNTERPARTY_ID"))
     p.setString("INSTRUMENT_ID", t?.getString("INSTRUMENT_ID"))
     ]]>
     </consolidationTarget>
     <calculation>
     <![CDATA[
     long quantity = t.getLong("QUANTITY")
     long previousQuantity = previous_t.getLong("QUANTITY")
     long prevPositionQuantity = p.getLong("QUANTITY")
     long newQuantity = prevPositionQuantity + (quantity - previousQuantity)
     
     p.setLong("QUANTITY", newQuantity)
     Double lastPrice = ip?.getDouble("LAST_PRICE")
     if (lastPrice != null) {
     p.setDouble("NOTIONAL", newQuantity * lastPrice )
     }
     ]]>
     </calculation>
     </consolidateTable>
     </consolidation>
    </consolidations>

![](/img/consolidator-logic-consolidate-positions.png)

## 4. Update the system files

### Update the processes.xml file

Add a new entry to **trading_app-processes.xml** with the consolidator2 process definition.

    <process name="TRADING_APP_CONSOLIDATOR">
     <groupId>TRADING_APP</groupId>
     <start>true</start>
     <options>-Xmx256m -DRedirectStreamToLog=true</options>
     <module>consolidator2</module>
     <package>global.genesis.consolidator2</package>
     <config>trading_app-consolidator2.xml</config>
     <loggingLevel>INFO,DATADUMP_OFF</loggingLevel>
     </process>

### Update the service-definitions.xml file

This file lists all the active services for the application. You can see entries have been added automatically when the data server, request server and event handler were generated (by AppGen). 

Add a new entry to **trading_app-service-definitions.xml** with the consolidator2 details. 

![](/img/add-to-service-defininitions.png)

## Testing

Optional? Create unit test to prove consolidator is working (test that when you insert a new trade in DB, a new position record is created with the relevant data after a while). You can have a look at core framework tests for this.