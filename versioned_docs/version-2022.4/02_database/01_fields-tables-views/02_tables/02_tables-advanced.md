---
title: 'Tables - advanced'
sidebar_label: 'Tables - advanced'
id: tables-advanced
keywords: [database, tables, advanced]
tags:
    - database
    - tables
    - advanced
---


## Subtables

A subtable provides a unique point of view on the data schema, which goes further than a simple join relationship. It gives extra functionality to a main table.

For example, a financial instrument can be modelled as an INSTRUMENT table, but this table on its own isn’t enough to represent all the possible symbologies for an instrument. So, we could add a subtable called ALT_INSTRUMENT_ID, in which the relationship is one-to-many from INSTRUMENT to ALT_INSTRUMENT_ID.

ALT_INSTRUMENT_ID is likely to inherit key fields from the INSTRUMENT table, and it simply acts as a lookup table for INSTRUMENT records.

This requirement occurs for different tables (e.g. COUNTERPARTY → ALT_COUNTERPARTY_ID, GENESIS_PROCESS → GENESIS_PROCESS_MONITOR, etc).

Subtables are defined within the body of the table definition. 

The example below shows the `GENESIS_PROCESS` monitoring table.

After the fields and the primary key have been defined, you can see the subtable `GENESIS_PROCESS_MONITOR`.

Within this subtable, the fields that are used to generate the join operation are defined first. These fields are inherited automatically. Then the additional fields and keys are defined.


```kotlin
table(name = "GENESIS_PROCESS", id = 12) {
    PROCESS_NAME
    PROCESS_STATUS
    PROCESS_STATUS_MESSAGE
    PROCESS_STATE_TEXT
    PROCESS_RESOURCES
    PROCESS_HOSTNAME
    PROCESS_CPU_USAGE
    PROCESS_MEM_USAGE
    PROCESS_SECURE
    PROCESS_PORT
    LOG_LEVEL
    DATADUMP
    START_TIME
    RESOURCE_TYPES
    primaryKey {
        PROCESS_NAME
        PROCESS_HOSTNAME
    }
    subTables {
        fields(PROCESS_HOSTNAME, PROCESS_NAME)
            .joiningNewTable(name = "GENESIS_PROCESS_MONITOR", id = 20) {
                MONITOR_NAME
                MONITOR_MESSAGE
                MONITOR_STATE

            primaryKey(name = "GENESIS_PROCESS_MONITOR_BY_HOSTNAME", id = 1) {
                    PROCESS_HOSTNAME
                    PROCESS_NAME
                    MONITOR_NAME
                }
            }
    }
}
```

## Auditing​

We want to be able to track the changes made to the various trades on the TRADE table, such that we could see the times and modifications made in the history of the trade. So, we are going to add basic auditing to the TRADE table in order to keep a record of the changing states of the trades.

This can be useful for historical purposes, if you need to at a later date be able to produce an accurate course of events.

### Structure of audit tables

When creating autiding tables, you will add a new table into your schema named `[TABLE_NAME]_AUDIT` with the same fields of the source table, added by:

| Field name                | Data Type | Description |
| ---                       | ---       | ---  |
| `AUDIT_EVENT_DATETIME`    | DATATIME  | Autogenerated date and time that the event has been received |
| `AUDIT_EVENT_TEXT`        | STRING    | Optional “REASON” value sent as part of the event message | 
| `AUDIT_EVENT_TYPE`        | STRING    | Event that wrote on the source table |
| `AUDIT_EVENT_USER`        | STRING    | User on the event message |
 
### Adding audit to table dictionary

In order to create an audit table, you need to add the parameter `audit = details()` into your table's definition. The parameters avaiable in `details()` are decribed below.

| Parameter name            | Type | Description |
| ---                       | ---       | ---  |
| `id`    | Integer  | **Unique** `id` to identify the audit table |
| `sequence`        | STRING    | **Unique** name to identify its `sequence`   | 
| `tskey`        | boolean  | Set a timestamp index |

The sintax is:

```kotlin title="{APP_NAME}-tables-dictionary.kts"
table (name = <TABLE_NAME>, id = <TABLE_ID>, audit = details(id = <TABLE_NAME_AUDIT_ID>, sequence = <TABLE_SEQUENCE>, tskey = <TRUE_OR_FALSE>))
        ...

```

#### Example

```kotlin
table (name = "TRADE", id = 2000, audit = details(id = 2100, sequence = "TR_AU", tskey = true)) {
    sequence(TRADE_ID, "TR")
    COUNTERPARTY_ID 
    INSTRUMENT_ID not null
    QUANTITY
    PRICE not null
    SYMBOL
    DIRECTION
    TRADE_DATE
    ENTERED_BY
    TRADE_STATUS

    primaryKey {
        TRADE_ID
    }
}

```

### Event Handlers with auditing tables

In order to be able insert automatically audit records to audit tables, you only need to follow the [previous steps](#adding-audit-to-table-dictionary). After that, every time an eventhandle interacts with any audited table, it will automatically insert an audit record.

To garantee that the audit record is inserted into the audit table, Genesis provide a parameter to eventhandlers called `transactional = true | false`.

**Transactional** eventhandlers are [ACID](../../../getting-started/glossary/glossary/#acid)-compliant, which means that it will use the concept of transactions to garantee that the audit record is inserted into the audit table. In other words, if `transactional = true` and the eventhandler triggered finishes its excecution, then it is garanteed that the audit record is inserted.

:::warning
Make sure your database supports transactions
:::


<!-- ### Event Handlers to use auditing

Now you must update the **alpha-eventhandler.kts** in order to pass the `entityDb` object into the updated methods of the state machine, as the **syncMultiEntityReadWriteGenericSupport** parameter. This should resemble the example below:

```kotlin {12,19,26,35}
    eventHandler<Trade>(name = "TRADE_INSERT") {
        onValidate { event ->
            val message = event.details
            verify {
                entityDb hasEntry Counterparty.ById(message.counterpartyId)
                entityDb hasEntry Instrument.ById(message.instrumentId)
            }
            ack()
        }
        onCommit { event ->
            val trade = event.details
            stateMachine.insert(entityDb, trade)
            ack()
        }
    }
    eventHandler<Trade>(name = "TRADE_MODIFY") {
        onCommit { event ->
            val trade = event.details
            stateMachine.modify(entityDb, trade)
            ack()
        }
    }
    eventHandler<TradeCancelled>(name = "TRADE_CANCELLED") {
        onCommit { event ->
            val message = event.details
            stateMachine.modify(entityDb, message.tradeId) { trade ->
                trade.tradeStatus = TradeStatus.CANCELLED
            }
            ack()
        }
    }
    eventHandler<TradeAllocated>(name = "TRADE_ALLOCATED") {
        onCommit { event ->
            val message = event.details
            stateMachine.modify(entityDb, message.tradeId) { trade ->
                trade.tradeStatus = TradeStatus.ALLOCATED
            }
            ack()
        }
    }
```
-->